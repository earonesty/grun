#!/usr/bin/perl

#    grun - lightweight jobs queueing system
#    Copyright (C) 2011 Erik Aronesty
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

use Carp;
use Getopt::Long qw(GetOptions);
use Data::Dumper;
use IO::Socket;
use IO::Select;
use IO::File;
use POSIX qw(:sys_wait_h strftime);
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Safe;
use Cwd;

our $VERSION = 0.8.141;				# 0.9 will be feature lock.   1.0 will be config backward lock

my $WIN32 = ($^O =~ /Win32/);
my $EOT = pack("cc",0,4);
my $SOCK_WAIT = -1;				# wait for resp
my $SOCK_FILE = -2;				# send files over socket
my $DEFAULT_MEM = 10000;

my ($daemon, $killjob, $editjob);
my (%conf, %def);

# defaults just run things locally, no master
$def{config} = "/etc/grun.conf";		# config file
$def{spool} = "/var/spool/grun";		# dir to place jobs
$def{port} = 5184;				# listen/connect port
$def{bind} = '0.0.0.0';				# listen addr
$def{env} = ['PATH','USER'];			# list of environment vars to copy from submit through to exec
$def{ping_secs} = 30;				# how often to tell about load/mem/stats
$def{remove_secs} = '$ping_secs * 1000';	# don't even try kickstarting if the node is this old
$def{idle_load} = .3;				# how often to tell about load/mem/stats
$def{retry_secs} = 60;				# how often to retry notifications
$def{max_buf} = 1000000;			# how often to retry notifications
$def{expire_secs} = 14400;			# remove jobs whose execution nodes haven't reported back in this amount of time
$def{io_keep} = 3600;				# keep io for this long after a job with i/o is finished in a detached session
$def{sched_secs} = '1';				# how often to try scheduling
$def{max_sched} = 50;				# how many different jobs to try and match before giving up on the rest (queue busy)
$def{master} = 'localhost:5184';		# central scheduler
$def{services} = "queue exec";			# all can run
$def{pid_file} = "/var/run/grun.pid";		# pid file
$def{log_file} = "/var/log/grun.log";		# pid file
$def{hostname} = $ENV{HOSTNAME} ? $ENV{HOSTNAME} : $ENV{COMPUTERNAME} ? $ENV{COMPUTERNAME} : `hostname`;
$def{log_types} = "note error warn";	# log all
chomp $def{hostname};

my ($qinfo, $help, $config);

Getopt::Long::Configure qw(require_order no_ignore_case passthrough);
GetOptions("daemon"=>\$daemon, "CONF:s"=>\$config, "trace"=>\$def{trace}, "query"=>\$qinfo) ||
	die usage();

if ($ARGV[0] eq '-?') {
	shift @ARGV;
	$help = 1;
}

$def{config} = $config if $config;

$help = 1 if defined $config && !$config;

if ($help) {
	print usage();
	exit 0;
}

if (!$daemon) {
	# -k <id> works as long as -d wasn't specified
	GetOptions("kill"=>\$killjob, "trace"=>\$def{trace}, "edit"=>\$editjob) ||
		die usage();
}

my $safe = new Safe;

init();

if ($conf{debug_memory}) {
	eval {require Devel::Gladiator;};
	die $@ if $@;
}

my $gjobid = slurp("$conf{spool}/nextid");

if ($qinfo) {
	# this is the code for grun -q

	Getopt::Long::Configure qw(no_require_order no_ignore_case passthrough);
	my %opt;
	GetOptions(\%opt, "silent", "inplace", "hosts=s") || die usage();
	my $cmd = shift @ARGV;
	die usage() if !$cmd;

	my @arg = @ARGV;
	$cmd =~ s/^-//;
	my $tmp = substr bestunique($cmd, qw(config status jobs file history)), 0, 4;
	if (!$tmp) {
		die "Command $cmd is not available, for help type grun -query -?\n";
	}
	$cmd = $tmp;

	# some commands default to localhost, others default to queue host... this is confusing... fix?

	my @dest = $opt{hosts} ? expandnodes($opt{hosts}) : 
		$cmd eq 'conf' ? [$conf{bind}, $conf{port}] : 
		[$conf{master},$conf{master_port}];

	if ($cmd eq 'file' && @dest > 1) {
		die "Command $cmd cannot be run on multiple hosts";
	}

	for my $d (@dest) {
	my ($host, $port) = @$d;

	if ($cmd eq 'file') {
		my $cwd = cwd;
		my @need;
		for (@arg) {
			next if -e $_;
			if ($_ !~ /^\//) {
				$_ = "$cwd/$_";	
			}
			push @need, $_;
		}
		sendcmd($host, $port, 'trace', 1) if ($conf{trace});
		if (@need) {
			my ($res, $error) = waitio({inplace=>$opt{inplace}}, $host, $port, "xcmd", 'file', @need);
			die $error, "\n" if $error && !$opt{silent};
			exit 1 if $error;
		}
		sendcmd($host, $port, 'trace', 0) if ($conf{trace});
	} elsif (!samehost($host,$conf{bind}) || (!$ENV{_GRUN} && (!$conf{services}->{queue} || $cmd =~ /^conf|stat$/))) {
		# this could get ugly, if called a lot, may want to make more efficient
		sendcmd($host, $port, 'trace', 1) if ($conf{trace});
		my ($res) = waitmsg($host, $port, "xcmd", $cmd, @arg, %opt);
		print $res;
		sendcmd($host, $port, 'trace', 0) if ($conf{trace});
	} else {
		if ($cmd eq 'stat') {
			print shownodes(@arg);
		}	
		if ($cmd eq 'jobs') {
			print showjobs(@arg);
		}	
		if ($cmd eq 'hist') {
			print showhist(@arg);
		}	
	}
	}
	exit 0;
}

my $gpid;						# daemon pid
if (open(IN, $conf{pid_file})) {
	$gpid = <IN>;
	close IN;
}

if ($killjob) {
	# grun -k code
	my $sig = 15;
	Getopt::Long::Configure qw(no_require_order no_ignore_case);
        GetOptions("signal|n=i"=>\$sig) || die usage();

	if ($conf{trace}) {
                sendcmd($conf{master}, $conf{master_port}, 'trace', 1);
	}

	my $exit = 0;
	for my $job (@ARGV) {
		if ($job !~ /^\d/) {
			my $tmp = slurp("$ENV{HOME}/.grun/jobx/$job");
			if (!$tmp) {
				warn "External job id '$job' not found on this machine\n";
				exit -1;
			}
			$job = $tmp;
		}
		my $err = kill_job($job, $sig);
		if (!defined($err) && $@) {
			warn $@,"\n";
			$exit=-1;
		} else {
			my $ok = ($err =~ /^Job.*(aborted|kill requested)/);
			warn "$err\n" if $ok; 
			$err = 'No response to jkill' if !$ok && !$err;
			warn "Error: $err\n" if !$ok;
			$exit=-1 if !$ok;
		}
		if ($job !~ /^\d/) {
			unlink "$ENV{HOME}/.grun/jobx/$job";
		}
	}
	exit 0;
}

if ($editjob) {
        my ($err) = waitmsg($conf{master}, $conf{master_port}, 'jedit', @ARGV);
        my $ok = ($err =~ /^Job.*edited/);
        warn "$err\n" if $ok;
	$err = 'No response to jedit' if !$ok && !$err;
        die "Error: $err\n" if !$ok;
        exit 0;
}

my ($listener, $read_set, $write_set, $quit, %io_wait, %run_wait);	# daemon globals

if ($daemon) {
	startdaemon();
	exit 0;
}

####################
# client mode

my %nodes;
my %jobs;
my %opt;

$opt{wait} = 1;				# keep socket open until job is finished
$opt{io} = 1;				# copy io back on the socket, implies wait

Getopt::Long::Configure qw(require_order no_ignore_case passthrough);
GetOptions(\%opt, "file=s", "memory|m=i", "hosts|h=s", "cpus|c=i", "io!", "wait!", "err=s", "out=s", "jobx|jobid|j=s", "verbose", "debug|D");

my $verbose = $opt{verbose}; delete $opt{verbose};

if ($opt{err} && $opt{out}) {
	$opt{wait} = $opt{wait} || $opt{io};
	$opt{io} = 0;
}

while ($ARGV[0] =~ /^--([\w-]+)=([\w=]+)/) {
	# allow arbitrary job options, that jan later be referred to in match expressions
	# or in execution wrappers, etc
	$opt{$1} = $2;
	shift @ARGV;
}

if ($ARGV[0] =~ /^-/) {
	die "Unknown option $ARGV[0]\n";
}

my @cmd = @ARGV;

if ($opt{file}) {
	# read options from a file
	funpack($opt{file}, \%opt);
	if ($opt{cmd}) {
		if (@ARGV) {
			die "Can't supply cmd: in the file and '@cmd' on the command line\n";
		}
		if ($opt{cmd} !~ /^[\w0-9:\/\t -]+$/) {
			# not simple: let bash handle it
			@cmd = ('bash', '-c', $opt{cmd});
		} else {
			# simple: split, pass as is to exec
			$opt{cmd} =~ s/^\s+//;
			$opt{cmd} =~ s/\s+$//;
			@cmd = split /\s+/, $opt{cmd};
		}
	}
}

#die Dumper \@cmd  if $opt{debug};

if ($opt{memory}) {
	$opt{memory} *= 1000;
	if ($opt{memory} =~ /gb?$/) {
		$opt{memory} *= 1000;
	}
	if ($opt{memory} =~ /kb?$/) {
		$opt{memory} /= 1000;
	}
}

if ($conf{auto_profile}) {
	if (-e ($conf{auto_profile})) {
		my $cmd = join ' ', @cmd;
		# safe'ish eval, just so there aren't weird side effects
		my ($cpu, $mem) = evalctx(slurp($conf{auto_profile}) . ";\nreturn (\$cpu, \$mem);", cmd=>$cmd, cmd=>\@cmd);
		$opt{memory}=$mem if ($mem > $opt{memory});
		$opt{cpus}=$cpu if ($cpu > $opt{cpus});
	}
}

if (!@cmd) {
	die usage();
}

# no socket io unless waiting
if (!$opt{wait}) {
	delete $opt{io};
}

# force exec in "same as current dir"
$opt{cwd} = cwd;

# copy env
for (@{$conf{env}}) {
	$opt{env}->{$_} = $ENV{$_} if defined $ENV{$_};
}
for (qw(USER)) {
	$opt{env}->{$_} = $ENV{$_};
}

$opt{user} = getpwuid($>);
$opt{umask} = umask();

my %info;
my $interrupt;

sub sigh {
	my $signame = shift;
	if ($info{jid}) {
		print STDERR "Aborting command, sending jkill for $info{jid}\n";
		my $err = kill_job($info{jid}, 2);
		if (!defined($err) && $@) {
			die $@,"\n";
		}
		exit -1;
	} else {
		# for now, don't interrupt the initial message
		# later, when we have client-generated job id's this will go away
		$interrupt = $signame;
	}
};

$SIG{INT} = \&sigh;
$SIG{TERM} = \&sigh;

if ($conf{trace}) {
	$opt{trace} = 1;
	sendcmd($conf{master}, $conf{master_port}, 'trace', 1);
}

%info = waitmsg($conf{master}, $conf{master_port}, 'run', \%opt, @cmd);

if ($interrupt) {
	sigh($interrupt);
}

if (!%info) {
	die "$@\n";
}

if ($info{error}) {
	print STDERR $info{error}, "\n";
	exit -1;
}

if (!$info{jid}) {
	print STDERR "Failed to submit job", "\n";
	exit -1;
}

if ($verbose) {
	printf STDERR "Job_ID:	$info{jid}\n";
	printf STDERR "Memory:	%d\n", $opt{memory} ? $opt{memory} : $DEFAULT_MEM/1000;
	printf STDERR "CPU:	%d\n", $opt{cpu} ? $opt{cpu} : 1;
}

if ($opt{jobx}) {
	# this is crappy... should be a totally separate set of id's... and should be on the central server
	# but too much code and not worth it for me right now
	# with sqlite would be easier
	if ($opt{jobx} =~ /^\d/) {
		die "External job id's should start with a non-numeric\n";
	}
	mkdir("$ENV{HOME}/.grun") if ! -d "$ENV{HOME}/.grun";
	mkdir("$ENV{HOME}/.grun/jobx") if ! -d "$ENV{HOME}/.grun/jobx";
	burp("$ENV{HOME}/.grun/jobx/$opt{jobx}", $info{jid});
}

if ($opt{wait}) {
	# wait for a job id
	while (!defined($info{ip})) {
		%info = waitmsg($conf{master}, $conf{master_port}, 'jinfo', $info{jid});
		if ($info{error}) {
			print STDERR $info{error}, "\n";
			exit -1;
		}
		if (!defined($info{ip})) {
			sleep(5);
		}
	}

	if ($verbose) {
		printf STDERR "Host:	%s\n", $info{ip};
	}

	# look at all the work you can avoid if you don't wait
	my ($stat, $err);
	# connect to executing node directly and ask for stderr, stdout, and status based on job id
	while (!defined $stat && !defined $err) {
		# shadow watcher....
		if ($info{ip}) {
			if ($opt{io} && !($opt{err} && $opt{out}) ) {
				($stat, $err) = waitio($info{ip}, $info{port}, 'xio', $info{jid});
			} else {
				($stat, $err) = waitmsg($info{ip}, $info{port}, 'xstat', $info{jid});
			}
			if ($stat == 65280 && !$err) {
				print STDERR "Error: Command returned -1\n";
			} 
		}
		sleep 5 if (!defined $stat && !defined $err);
	}
	if (defined $stat) {
		# send this command into the ether...if exec doesn't get it, clean up after timeout
		if ($opt{io}) {
			sendcmd($info{ip}, $info{port}, 'xclean', $info{jid});
		}
	}
	if ($stat == 11) {
		$err = 'Segmentation fault';
	}
	if ($err) {
		print STDERR $err, "\n";
	}
	unlink("$ENV{HOME}/.grun/jobx/$opt{jobx}") if $opt{jobx};
	exit $stat>>8;
} else {
	# aah... nicer
	print STDOUT "Job id $info{jid}\n";
}

END {
	if (!$daemon && $conf{trace}) {
		sendcmd($conf{master}, $conf{master_port}, 'trace', 0);
	}
}

sub readsocks {
	# based on ppcgid, nonforking socket code
	my $ret=0;

    	my ($new_readable, $new_writable, $new_error) = IO::Select->select($read_set, $write_set, $read_set, 1);

	# remember: if the thing you're doing is slower than forking... fork
	foreach my $sock (@$new_readable) {
		if ($sock == $listener) {
			my $new_sock = $sock->accept();
			if ($new_sock) {
			    if ($WIN32) {
				ioctl($new_sock, 0x8004667e, pack("I", 1));
			    } else {
				fcntl($new_sock, F_SETFL, O_NONBLOCK);
			    }
			    $read_set->add($new_sock);
			    *$new_sock{HASH}->{time} = time();
			}
		} else {
			my $buf;
			my $bytes_read = sysread($sock, $buf, 4096);

			if (substr($buf,-2,2) eq $EOT) {
				substr($buf,-2,2) = '';
				$buf = *$sock{HASH}->{buf}.$buf;
				my @resp = process_message($buf, $sock);
				delete *$sock{HASH}->{buf};
				if (!@resp) {
					xlog("debug", "Closing $sock sock after EOT\n") if $conf{trace};
					close_sock($sock);
				} elsif ($resp[0] eq $SOCK_WAIT) {
					xlog("debug", "Setting $sock to wait mode\n") if $conf{trace};
					# leave it open, and in the read-list
				} elsif ($resp[0] eq $SOCK_FILE) {
					# read from one or more files, and send them through the socket
					xlog("debug", "Got a file request [@resp]\n") if $conf{trace};
					*$sock{HASH}->{file} = [splice(@resp, 1)];
					$write_set->add($sock);
				} else {
					xlog("debug", "Packing $sock after resp\n") if $conf{trace};
					*$sock{HASH}->{resp} = packcmd(@resp);
					$write_set->add($sock);
				}
			} else {
				# append to growing message
				if ($bytes_read == 0) {
					xlog("debug", "Closing $sock after BR=0\n") if $conf{trace};
					close_sock($sock);
				} else {
					*$sock{HASH}->{buf} .= $buf;
				}
			}
		}
		$ret = 1;
	}

    	foreach my $sock ($write_set->can_write(0)) {
		if (!*$sock{HASH}->{resp} && *$sock{HASH}->{file}) {
			if (*$sock{HASH}->{io}) {
				*$sock{HASH}->{resp} = '';
				*$sock{HASH}->{resp_offset} = 0;
				if (!sysread(*$sock{HASH}->{io}, *$sock{HASH}->{resp}, 4096)) {
					close *$sock{HASH}->{io};
					delete *$sock{HASH}->{io};
				}
			}
			if (!*$sock{HASH}->{io}) {
				my $file = splice(@{*$sock{HASH}->{file}}, 0, 1);
				while (-d $file) {
					# requests for directories are, for now, summarily ignored
					$file = splice(@{*$sock{HASH}->{file}}, 0, 1);
				}
				if ($file) {
					xlog("debug", "Sending $file over $sock\n") if $conf{trace};
					my $head = "name:$file\nlen:" . (-s $file) . "\n";
					my $io = new IO::File;
					if (!open ($io, $file)) {
						$head .= "error:'$file' : $!\n";
					} else {
						*$sock{HASH}->{io} = $io;
					}
					*$sock{HASH}->{resp} = $head . "\n";
					*$sock{HASH}->{resp_offset} = 0; 
					sysread(*$sock{HASH}->{io}, *$sock{HASH}->{resp}, 4096, length(*$sock{HASH}->{resp})); 
				} else {
					delete *$sock{HASH}->{file};
				}
			}
		}

    		if (*$sock{HASH}->{close}) {
			xlog("debug", "Closing $sock after close flag\n") if $conf{trace};
			close_sock($sock);
		} elsif (length(*$sock{HASH}->{resp})) {
			xlog("debug", "Writing $sock " . substr(*$sock{HASH}->{resp},0,1000)) if $conf{trace};

			my $nb = syswrite($sock, *$sock{HASH}->{resp}, length(*$sock{HASH}->{resp}), *$sock{HASH}->{resp_offset});
			if (!$nb) {
				xlog("error", "Socket failed to write", $sock);
				close_sock($sock);
			} else {
				*$sock{HASH}->{resp_offset}+= $nb;
				if (*$sock{HASH}->{resp_offset} >= length(*$sock{HASH}->{resp})) {
					delete *$sock{HASH}->{resp};
					if (!*$sock{HASH}->{file}) {
						*$sock{HASH}->{close} = 1;
					}
				}
			}		
		} else {
			xlog("debug", "Closing $sock after nothing to do\n") if $conf{trace};
			close_sock($sock);
		}
		$ret = 1;
	}

	return $ret;
}

sub close_sock {
	my ($sock) = @_;
	$read_set->remove($sock);
	$write_set->remove($sock);
	close($sock);
}

sub selfcmd {
	my $cmd = packcmd(@_);
	substr($cmd,-2,2) = '';
	# socket should be a dev-null connection or something, but whatever
	process_message($cmd, $listener);
}

sub process_message {
	my ($data, $sock) = @_;
	xlog("note", "Received command $data from " . $sock->peerhost() . "\n") if $conf{trace};

	my ($cmd, @args) = unpackcmd($data);
	return ('error'=>$@) if ($@);

	if ($cmd eq 'xcmd') {
		# these commands 'query or interfere' with normal running of the server 
		# they are initiated by a user	
		# they are limped together like this for basically no reason

		my $ip = $sock->peerhost();

		if ($args[0] eq 'relo') {
			# reread config... maybe rebind stuff too
			xlog("note", "Reload from remote command ($ip)");
			init();
			return 'ok';
		} elsif ($args[0] eq 'term') {
			xlog("note", "Shutdown from remote command ($ip)");
			$quit = 1;
			return 'ok';
		} elsif ($args[0] eq 'rest') {
			xlog("note", "Restarting from remote command ($ip)");
			close_sock($listener);
			if (!fork) {
				exec($0, '-d');
			}
			$quit = 1;
			return "ok";
		} elsif ($args[0] eq 'stat') {
			shift @args;
			return shownodes(@args);
		} elsif ($args[0] eq 'hist') {
			shift @args;
			return showhist(@args);
		} elsif ($args[0] eq 'conf') {
			return showconf();
		} elsif ($args[0] eq 'jobs') {
			shift @args;
			return showjobs(@args);
		} elsif ($args[0] eq 'file') {
			shift @args;
			xlog("note", "Sending file [@args] to remote via xcmd ($ip)");
			return ($SOCK_FILE, @args);
		} else {
			return "Error: unknown xcmd '$args[0]'";	
		}
	} elsif ($cmd eq 'trace') {
		# turn tracing on... should be 'session' oriented but too lazy for now
		if ($conf{trace} <= 1) {
			$conf{trace} = 0+$args[0];
		}
		return ();
	} elsif ($cmd eq 'node') {
		# this is the 'node ping'
		if (ref($args[0]) eq 'HASH') {		# bit of validation
			my $ip = $sock->peerhost();	# store info in a file, for fun
			my $file = "$conf{spool}/nodes/$ip.reg";
			if (!$ip) {
				xlog("error", "Socket has no ip?");
			}
			open(F, ">$file") || return("Error: can't create $file : $!");
			print F $data;
			close F;
			# also stick in memory
			my $node = $args[0];
			if (!$nodes{$ip}) {
				xlog("note", "Registering node $ip:$node->{port} $node->{hostname}");
			}
			$nodes{$ip} = $args[0];
			$nodes{$ip}->{ip} = $ip;
			# save execution node ping time for diagnostic (times out of sync or very slow transmission, etc)
			$nodes{$ip}->{ex_ping} = $nodes{$ip}->{ping};
			$nodes{$ip}->{ping} = time();
		} else {
			return "Error: invalid node registration info";	
		}
		return ();
        } elsif ($cmd eq 'jedit') {
		my ($jid, $key, $val) = @args;
		if (!$key || !defined($val)) {
                	xlog("error", "Invalid edit request ($jid,$key,$val)");
                	return "Invalid edit request ($jid,$key,$val)\n";
		} elsif (! -e "$conf{spool}/jobs/$jid") {
                        if (! -e "$conf{spool}/jobs/$jid.ip") {
                                xlog("error", "Job $jid not found");
                                return "Job $jid not found";
                        } else {
                                my $ip = slurp("$conf{spool}/jobs/$jid.ip");
                                # tell client to send an 'xedit' to the running node
                                return "Forward $ip:" . $nodes{$ip}->{port};
                        }
                } else {
			my $ref = $safe->reval(slurp("$conf{spool}/jobs/$jid"));
			$ref->[0]->{$key} = $val;
			burp("$conf{spool}/jobs/$jid.jedit");
			rename("$conf{spool}/jobs/$jid.jedit", "$conf{spool}/jobs/$jid");
                        return "Job $jid edited\n";
                }
        } elsif ($cmd eq 'jkill') {
		# this is the 'job kill command'
		my ($jid, $force) = @args;

		if (! -e "$conf{spool}/jobs/$jid") {
			if (! -e "$conf{spool}/jobs/$jid.ip") {
				xlog("error", "Job $jid not running, but kill requested");
				unlink "$conf{spool}/jobs/$jid";
				return "Job $jid not running";
			} else {
				# send xabort to correct node
                                my $ip = slurp("$conf{spool}/jobs/$jid.ip");
				if (!$ip) {
					xlog("error", "Job $jid empty ip!");
					unlink "$conf{spool}/jobs/$jid";
					unlink "$conf{spool}/jobs/$jid.ip";
				} else {
					if ($force && ($force eq $ip)) {
						unlink "$conf{spool}/jobs/$jid.ip";
						unlink "$conf{spool}/jobs/$jid:$ip.run";
						xlog("error", "Job $jid forced kill");
						return "Job $jid forced kill\n";
					} elsif ($force) {
						xlog("error", "Job $jid force kill requested for ip $ip");
						return "Job $jid ip mismatch, force failed\n";
					} else {
						return "Forward $ip:" . $nodes{$ip}->{port};
					}
				}
			}
		} else {
			unlink "$conf{spool}/jobs/$jid";
			return "Job $jid aborted\n";
		}
	} elsif ($cmd eq 'jstat') {
		# sent by the execution node to say what the status of a job is
		my %opts = @args;
		if ($opts{id}) {
			my $ip = $sock->peerhost();	# should match the ip from jmine (see above how dumb this is)
			# temporarily added to recover from errors, but maybe make this allowed for real?
			# any harm in trying to recover from false orphans?
			#
			#if (! -e "$conf{spool}/jobs/$opts{id}:$ip.run") {
			#	
			#	if (-e "$conf{spool}/jhist/0/$opts{id}") {
			#		burp("$conf{spool}/jobs/$opts{id}:$ip.run", slurp("$conf{spool}/jhist/0/$opts{id}"));
			#	}
                        #       if (! -e "$conf{spool}/jobs/$opts{id}.ip" ) {
			#		burp("$conf{spool}/jobs/$opts{id}.ip",$ip);
			#	}
			#}
			if (! -e "$conf{spool}/jobs/$opts{id}:$ip.run") {
                                my $should = slurp("$conf{spool}/jobs/$opts{id}.ip");
				
				if (!$should) {
					xlog("error", "Got a report ($opts{status},$opts{jrun}) for job $opts{id} from $ip, which has no $conf{spool}/jobs/$opts{id}.ip");
				} else {
					if ($opts{pid}<0) {
						xlog("error", "Orphaned job report $opts{id}");
						$ip=$should if !$ip;
					} else {
						if (!($ip eq $should)) {
							xlog("error", "Got a report ($opts{status},$opts{jrun}) for job $opts{id} from $ip, should be $should");
						} else {
							xlog("error", "Got a report ($opts{status},$opts{jrun}) for job $opts{id}, but there's no $opts{id}:$ip.run file");
							burp("$conf{spool}/jobs/$opts{id}:$ip.run","[{},'<unknown>']");
						}
					}
				}
			}
			if ($opts{jrun}) {
				# just a ping
				xlog("error", "Oh, i'm still alive $opts{id} from $ip") 
					if $opts{trace} || $conf{trace};
				touch("$conf{spool}/jobs/$opts{id}:$ip.run")
					if -e "$conf{spool}/jobs/$opts{id}:$ip.run";
			} elsif (defined $opts{status}) {
				# job is done
				my $jhist = slurp("$conf{spool}/jobs/$opts{id}:$ip.run");
				my $status = 0+$opts{status};

				xlog("debug", "Unlinking $conf{spool}/jobs/$opts{id}:$ip.run, $conf{spool}/jobs/$opts{id}.ip ($jhist)");

				unlink("$conf{spool}/jobs/$opts{id}:$ip.run");
				unlink("$conf{spool}/jobs/$opts{id}.ip");

				my %stat = %opts;
				delete $stat{status};	# don't repeat info in the history file
				delete $stat{id};

				xlog("debug", "Writing history for $opts{id} " . packref(\%stat));
				open(ST, ">" . jhistpath($opts{id}));
				my $extr = "host=>'$ip', status=>$status, usage=>" . packref(\%stat);
				if ($jhist) {
					substr($jhist,0,2) = "[{$extr,";
				} else {
					$jhist = "[{$extr},'<unknown>']";
				}
				xlog("debug", "Writing $jhist to " . jhistpath($opts{id}));
				print ST $jhist;
				close ST;
			} else {
				xlog("error", "Got a report for a job $opts{id} with no status info");
			}
			# return ack even if not exists
			return ('dack', pid=>$opts{pid}, jrun=>$opts{jrun});	
		}
        } elsif ($cmd eq 'dack') {
		# ackknowledge receipt of status signal, so you don't have to do it again
                my %opts = @args;
                if ($opts{pid}) {
			if (!$opts{jrun}) {
				# stop tracking this pid
				my $info = gunpack(slurp("$conf{spool}/pids/$opts{pid}"));
				unlink("$conf{spool}/pids/$opts{pid}");
				if (!$info->{wait}) {
					# nobody asked for the output, so don't keep it
					unlink("$conf{spool}/jpids/$info{id}");
					unlink("$conf{spool}/pids/$opts{pid}.stat");
					unlink("$conf{spool}/stdio/$opts{pid}.err");
					unlink("$conf{spool}/stdio/$opts{pid}.out");
				}
			}
		}
	} elsif ($cmd eq 'exec') {
		my ($opts, @cmd) = @args;

		my ($uid, $gid, $err);
		if ($opts->{user}) {
			(undef, undef, $uid, $gid) = getpwnam($opts->{user});
		}
		if (defined($uid) && !$conf{run_asroot} && !$uid) {
			$err="Won't run as root";
		}
		if (!defined($uid)) {
			$err="User $opts->{user} is unknown on this machine, not executing";
		}

		# expecting someone to come pick up output?
		$io_wait{$opts->{id}}->{type} = 'stat' if $opts->{wait};	# status wait
		$io_wait{$opts->{id}}->{type} = 'io' if $opts->{io};		# io wait

		my $pid;

		if ($conf{wrap}) {
			@cmd = ($conf{wrap}, @cmd);
		}

		if (!$err && !($pid=fork)) {
			if (! defined $pid) {
				$err = "Can't fork";
			} else {
				# restore signal to default ... regular kill
				$SIG{INT} = undef;
				$SIG{TERM} = undef;

				# kill me with a negative number, all kids die too
				# kill my parent.... i stay alive, and my IO is still ready to go
				POSIX::setsid();

				my $ok=1;	
				if ($opts->{err}) {
					$ok&&=open(STDERR, ">", $opts->{err});
				}
				if ($opts->{out}) {
					if ($opts->{out} eq $opts->{err}) {
						$ok&&=open(STDOUT, ">>", $opts->{out});
					} else {
						$ok&&=open(STDOUT, ">", $opts->{out});
					}
				}
				if ($opts->{io}) {
					if (!$opts->{err}) {
						$ok&&=open(STDERR, ">$conf{spool}/stdio/$$.err");
					}
					if (!$opts->{out}) {
						$ok&&=open(STDOUT, ">$conf{spool}/stdio/$$.out");
					}
				} else {
					# save disk and time, i never want i/o
					if (!$opts->{err}) {
						$ok&&=open(STDERR, ">/dev/null");
					}
					if (!$opts->{out}) {
						$ok&&=open(STDOUT, ">/dev/null");
					}
				}
			
				if (!$ok) {
					xlog("error", "Error opening i/o files : $!\n");
				}	

				# copy in the umask & the environment
				umask $opts->{umask};
				for (keys(%{$opts->{env}})) {
					$ENV{$_}=$opts->{env}->{$_};
				}
			
				for (keys(%{$opts})) {
					next if ref($opts->{$_});
					$ENV{"_GRUN_OPT_$_"} = $opts->{$_};
				}
				$ENV{"_GRUN"} = 1;
				my $err;
				my $ret;

				xlog("debug", "Setting uid to $uid, gid to $gid.\n") if ($conf{trace} || $opts->{trace});

				eval {	
					if ($gid) {
						$) = $gid;
						$( = $gid;
					}
					$> = $uid;
					$< = $uid;
					if ($opts->{cwd}) {
						if (!chdir($opts->{cwd})) {
							$err = "Can't cd to $opts->{cwd} : $!";
							$ret = 103;
						}
					}
				};

				if (!$err && $@) {
					$ret = 102;
					$err = "Error setting uid to $uid: $@\n";
				}
				if (!$err) {
					exec(@cmd);
					printf STDERR "Can't exec $cmd[0] : $!\n";	
					exit 101;
				} else {
					printf STDERR "$err\n";	
					exit $ret;
				}
				# special exit code 101 means couldn't run the command
			}
		}

		if ($err) {
			# fake it
			$pid = 'e' . $opts->{id};
			xlog("note", "Error $err with job $opts->{id}");
		}

		xlog("note", "Starting job $opts->{id}, pid $pid, '@cmd'") if !$err;

		my $file = "$conf{spool}/pids/$pid";

		if (!open(F, ">>$file"))  {
			xlog("error", "Can't create $file : $!");
		}
		print F "ip:" . $sock->peerhost() . "\n";
		print F "id:" . $opts->{id} . "\n";
		print F "port:" . $opts->{port} . "\n";
		print F "wait:" . $opts->{wait} . "\n";
		print F "io:" . $opts->{io} . "\n";
		print F "error:" . $err . "\n" if $err;
		close F;

		$file = "$conf{spool}/jpids/$opts->{id}";
		if (!open(F, ">$file")) {
			xlog("error", "Can't create $file : $!");
		}
		print F $pid;
		close F;

		if ($err) {
			if (writestat($pid, -3, 0, $err)) {
				notifystat($pid);
			}
		}
	} elsif ($cmd eq 'xclean') {
		# cleanup, i got everything
		my ($jid) = @args;
		my $pid = slurp("$conf{spool}/jpids/$jid");
		if ($pid > 1) {
			unlink  "$conf{spool}/jpids/$jid", "$conf{spool}/stdio/$pid.out", "$conf{spool}/stdio/$pid.err", "$conf{spool}/pids/$pid.stat";
		} else {
			xlog("error", "Got a cleanup for $jid which doesn't exist");
		}
        } elsif ($cmd eq 'xabort') {
                # kill job
                my ($jid, $sig) = @args;
                my $pid = slurp("$conf{spool}/jpids/$jid");
		if ($pid > 1) {
			$sig = 2 if !$sig;
			# perl kill didn't work!
#			my $ok = system("kill", "-$sig", "-$pid");
			my $ok = kill($sig, -$pid);
			xlog("note", "Kill ($sig) job $jid (pgrp:$pid), return: $ok");
			if ($ok) {
				return "Job $jid aborted"; 
			} else {
				return "Job $jid kill $sig failed : $!"; 
			}
		} else {
			return "Job $jid not found";
		}
	} elsif ($cmd eq 'xio') {
		my ($jid) = @args;
                my $pid = slurp("$conf{spool}/jpids/$jid");
		# someone has showed recent interest in this one
		touch("$conf{spool}/jpids/$jid");
		$io_wait{$jid}->{type} = 'io';
		$io_wait{$jid}->{sock} = $sock;
		$io_wait{$jid}->{time} = time();		# toss this entry if it gets old
#		print "IOWAIT: " . Dumper \%io_wait;
		if ($pid <= 1) {
			return "name:fake.err\nlen:13\n\nJob not foundname:fake.out\nlen:0\n\nname:fake.stat\nlen:4\n\n-102";
		}
		return ($SOCK_WAIT);				# leave socket open for response
        } elsif ($cmd eq 'xstat') {
                my ($jid) = @args;
		my $pid = slurp("$conf{spool}/jpids/$jid");
		# xstat means you don't want i/o, just status... 
		unlink  "$conf{spool}/stdio/$pid.out";
		$io_wait{$jid}->{type} = 'stat';
		$io_wait{$jid}->{sock} = $sock;
		$io_wait{$jid}->{time} = time();		# toss this entry if it gets old
		if ($pid <= 1) {
			xlog("error", "Wait xstat for job ($jid) which isn't running");
			return (-102, "Job $jid not found")
		}
		return ($SOCK_WAIT);				# leave socket open for response
	} elsif ($cmd eq 'jinfo') {				# tell me what host a job is on
                my ($jid) = @args;
                if (!$jid || ! -e "$conf{spool}/jobs/$jid") {
                        if (! -e "$conf{spool}/jobs/$jid.ip") {
				my $ip = $sock->peerhost();
                                xlog("error", "Job '$jid' does not exist from $ip");
                                return (error=>"Job $jid does not exist.", jid=>-1, ip=>$conf{master}, port=>$conf{master_port});
                        } else {
                                my $ip = slurp("$conf{spool}/jobs/$jid.ip");
				if (!$ip) {
					xlog("error", "No ip for job $jid");
				}
                                # route to correct node
				return (jid=>$jid, ip=>$ip, port=>$nodes{$ip}->{port});
                        }
                } else {
			$run_wait{$jid}->{sock} = $sock;
			$run_wait{$jid}->{type} = 'start';      # socket waits for execution start
			return ($SOCK_WAIT);                    # leave socket open for response
		}
	} elsif ($cmd eq 'run') {
		# user command, returns jid=>jobid [, error=>string]
		if (!$conf{services}->{queue}) {
			return (error=>"No queue service running on this host");	
		} else {
			# get rid of the 'run' at the front of the array
			return(error=>"Network data format error ($data)") 
				unless $data =~ s/^\['run',/[/;

			my ($opts) = @args;
			my $time = time();
			++$gjobid;

			# no half-written id's
			burp("$conf{spool}/nextid.tmp", $gjobid);
			rename "$conf{spool}/nextid.tmp", "$conf{spool}/nextid";

			# the job file
			my $jid = $gjobid;
			my $file = "$conf{spool}/jobs/$jid";

			# stick the host the job came from and the start time in there.
			my $ip = $sock->peerhost();
			substr($data,0,2) = "[{time=>" . $time . "," . "from=>'" . $ip . "',";

			open(F, ">$file") || return('error'=>"Can't create $file : $!");
			print F $data;
			close F;

			return (jid=>$jid);
		}	
	} else {
		return ('error'=>"Unknown command $cmd ($data)");
	}

	return ();
}

sub jhistpath {
	my ($id) = @_;
	my $left = int($id/10000);
	my $right = $id;
	my $dir = "$conf{spool}/jhist/$left";
	mkdir($dir) if ! -d $dir;
	return "$dir/$right";
}

sub schedule {
	opendir(D,"$conf{spool}/jobs");

	return unless %nodes;

	if (time() > ($conf{lastschedtime} + $conf{sched_secs})) {
		$conf{lastschedtime} = time();
	} else {
		return;
	}

	for my $n (values %nodes) {
		if ($n->{ip}) {
			$n->{a_cpus} = $n->{a_memory} = 0;
		}
	}

	# no attempt here to prioritize jobs, just match and go
	my %alloc;
	my $cnt=0;
	while(my $jid=readdir(D)) {
		my $jfil = "$conf{spool}/jobs/$jid";
		# probably should have a folder per job to avoid this
		next if ($jfil =~ /\.ip$/);

		next unless -f $jfil;
		my $ref = $safe->reval(slurp($jfil));
		if (!(ref($ref) eq 'ARRAY')) {
			xlog("error", "Invalid job file format: $jfil\n");
			unlink $jfil;
		}

		my $job = $ref->[0];

		# this should be config, min requirements
		$job->{cpus} = 1 if $job->{cpus} == 0;
		$job->{memory} = $DEFAULT_MEM if $job->{memory} == 0;

		if ($jfil =~ /\.run$/) {
			# job is running, make sure it's resources are somewhat locked
			($jid) = $jid =~ m/^(\d+)/;
			# check to see whether job has expired
			if (!$conf{loop_num}>2 && $conf{expire_secs} && (fmodtime($jfil) < (time()-$conf{expire_secs}))) {
#				xlog("error", "Not expiring job $jid, but I should");
			        selfcmd('jstat', pid=>-1, id=>$jid, status => -8, error=>"Orphaned job (" . (time()-fmodtime($jfil)) . "s)");
			} else {
				my $ip = slurp("$conf{spool}/jobs/$jid.ip");
				if ($ip =~ /\d/ && $nodes{$ip} && $nodes{$ip}->{ip}) {
					$nodes{$ip}->{a_cpus} += $job->{cpus};
					$alloc{$ip}->{a_memory} += $job->{memory};
				}	
			}
			next;
		}

		my @dereg;
		my @n;
		my ($max_av, $max_n);

		if ($cnt >= $conf{max_sched}) {
			last;
		}
		++$cnt;
		for my $n (values %nodes) {
			# jobs need enough memory, cpu availability and disk space... that's it
			if (!$n->{ip}) {
				xlog("error", "Node has no ip! " . packdump($n));
				next;
			}

			my $cpus = $n->{cpus} - $n->{a_cpus};
			$cpus = $n->{avail} if $n->{avail} < $cpus;

			my $mem = $n->{tmem} - $n->{a_memory};
			$mem = $n->{mem} if ($n->{tmem} == 0) || ($n->{mem} < $mem);

			#xlog("debug", "Sched $n->{ip}: j:$job->{cpus}?$n->{avail}>c:$cpus , j:$job->{memory}?$n->{mem}>m:$mem");

			if ($n->{ping} > (time()-$conf{ping_secs}*3)) {
				if ( ($mem >= $job->{memory}) &&
				     (($cpus+$conf{idle_load}) >= $job->{cpus}) && 
				     ($n->{disk} >= $job->{disk}) 
				   ) {
					next if $job->{hosts} && $job->{hosts} !~ /$n->{hostname}/;

					my $match = 1;
					if ($conf{match}) {
						$match = evalctx($conf{match}, node=>$n, job=>$job);	# eval perl expression
						if ($@) {
							$match = 1;						# permit all on error?
						}
					}
					next unless $match;

					if ($n->{load} < $conf{idle_load}) {
						# don't bother checking further, this node is bored
						$max_n = $n;
						last;
					} else {
						if ($n->{avail} > $max_av) {
							$max_n = $n;
							$max_av = $n->{avail};
						}
					}
				}
			} else {
				push @dereg, $n->{ip} if $n->{ip};
			}
		}
		for my $ip (@dereg) {
			xlog("note", "Deregister node '$ip', last ping was " . (time()-$nodes{$ip}->{ping}) . " seconds ago");
			delete $nodes{$ip};
		}
		if ($max_n) {
			# todo... change this
			my $jmine = "$jfil:" . $max_n->{ip} . ".run";
			touch($jfil);
			rename($jfil, $jmine);
			if ( -e $jmine ) {
				my $jptr = "$jfil" . ".ip";
				burp($jptr, $max_n->{ip});
				if (!noderun($max_n, $jid, $ref)) {
					# failed to execute job, put it back
					rename($jmine, $jfil);
					$max_n->{avail} = 0;
				} else {
					$max_n->{avail} -= $job->{cpus};
					$max_n->{memory} -= $job->{memory};
					$max_n->{a_cpus} += $job->{cpus} + 1;
					$max_n->{a_memory} += $job->{memory}; 
				}
			}
		} else {
			if ($conf{backup_grid}) {
				# TODO: fork exec to backup grid, and add to list of pids to track... as if you're an exec node
			}
			# xlog("debug", "Can't find node for $jfil " . Dumper(%nodes) . "\n") if $conf{trace};
		}
	}

	# kickstart nodes, if needed
	kicknodes();

	return undef;
}

sub noderun {
	my ($n, $jid, $job) = @_;
	# send 'exec'
	$job->[0]->{port} = $conf{port};		# reply to me on this port
	$job->[0]->{id} = $jid;
	if ($run_wait{$jid}) {
		# info needed for status/stdio collection
		if ($run_wait{$jid}->{type} eq 'start') {
			my $pid = $run_wait{$jid}->{pid};
			my $sock = $run_wait{$jid}->{sock};
			sockresp($run_wait{$jid}->{sock}, jid=>$jid, ip=>$n->{ip}, port=>$n->{port});
		}
	}
	return sendcmd($n->{ip}, $n->{port}, 'exec', @$job);
}

sub sockresp {
	my $sock = shift @_;
	*$sock{HASH}->{resp} = packcmd(@_);
	$write_set->add($sock);
}

# called at start, and kill -HUP
sub init {
	if (!$ENV{HOSTNAME}) {
		$ENV{HOSTNAME} = `hostname`;
		chomp $ENV{HOSTNAME};
	}
	readconf();
	if ($daemon) {
		mkdir $conf{spool};
		mkdir "$conf{spool}/jobs";
		mkdir "$conf{spool}/stdio";
		mkdir "$conf{spool}/jhist";
		mkdir "$conf{spool}/nodes";
		mkdir "$conf{spool}/pids";
		mkdir "$conf{spool}/jpids";
		# reregister on reread
		delete $conf{node};
	}
	$conf{hostip} = host2ip($conf{hostname});
}

sub getmem {
	my ($cache, $free, $tot);
	open F, "/proc/meminfo";
	while (<F>) {
		$tot = $1 if /MemTotal:\s*(\d+)/i;
		$free = $1 if /MemFree:\s*(\d+)/i;
		$cache = $1 if /Cached:\s*(\d+)/i;
		last if $cache & $free;
	}
	close F;
	return ($tot, $cache + $free);
}

sub getcpus {
	my $cores;
	open F, "/proc/cpuinfo";
	my %cores;
	my $p;
        while (<F>) {
                $p = $1 if /physical id\s*:\s*(\d+)/i;
                $cores{"$p$1"} = 1 if /core id\s*:\s*(\d+)/i;
                $cores += 1 if /processor\s*:\s*(\d+)/i;
        }
	close F;
	$cores = scalar keys %cores if %cores;
	return $cores;
}

sub slurp
{
    my $dat;
    my $in = new IO::File;
    return undef unless open($in, $_[0]);
    local $/ = undef;
    $dat = $in->getline;
    $in->close;
    return $dat;
}

sub srvexec {
	if ($conf{services}->{exec} && (!$conf{node} || (time() > ($conf{node}->{ping}+$conf{ping_secs}-1)))) {
		# ping master with stats
		$conf{node}->{arch} = `arch`; chomp $conf{node}->{arch};
		($conf{node}->{tmem},$conf{node}->{mem}) = getmem();					# free mem
		$conf{node}->{load} = slurp("/proc/loadavg");			# load
		$conf{node}->{cpus} = $conf{cpus} ? $conf{cpus} : getcpus();	# num cores
		$conf{node}->{avail} = $conf{node}->{cpus} - $conf{node}->{load};	
		$conf{node}->{ping} = time();
		$conf{node}->{port} = $conf{port};
		$conf{node}->{hostname} = $conf{hostname};
		$conf{node}->{kernel} = `uname -rv`; chomp $conf{node}->{kernel};
		$conf{node}->{arch} = `uname -m`; chomp $conf{node}->{arch};
		
		$conf{registered} = 1;
		if (!xsend("node", $conf{node})) {
			$conf{registered} = 0;
		}
	}

	# this needs to be wait3 for cpu/mem usage history, maybe use Inline::C
	while (1) {
		my ($kid, $status, @rd) = waitusage(-1, WNOHANG);
		last if $kid <= 0;
#		print "waitpid worked status is $?\n";
		if (writestat($kid, $status, undef, undef, \@rd)) {
			$conf{node}->{ping}-=5;					# hurry up to let scheduler know I'm free
			notifystat($kid);
		} else {
			xlog("error", "Premature status sent on pid $kid");
		}
	};

	# anyone who'se waiting, and has a pid and a socket... deal with it
	for my $jid (keys(%io_wait)) {
		my $pid = $io_wait{$jid}->{pid};
		if ($pid) {
			if ($io_wait{$jid}->{sock}) {
				my $sock = $io_wait{$jid}->{sock};
				# assert $pid = $io_wait{$jid}->{pid}
				if ($io_wait{$jid}->{type} eq 'io') {
					# need all IO
#					print "SENDING FILES : " . Dumper $io_wait{$jid};
					if ($io_wait{$jid}->{status}) {
						burp("$conf{spool}/pids/$pid.err", $io_wait{$jid}->{error}) 
							if ! -e "$conf{spool}/pids/$pid.err"; 
						burp("$conf{spool}/pids/$pid.stat", $io_wait{$jid}->{status}) 
							if ! -e "$conf{spool}/pids/$pid.stat"; 
					}
					*$sock{HASH}->{file} = ["$conf{spool}/pids/$pid.stat", "$conf{spool}/stdio/$pid.out", "$conf{spool}/stdio/$pid.err"];
					$write_set->add($sock);
				} elsif ($io_wait{$jid}->{type} eq 'stat') {
					# only want a status code
					my $stat = funpack("$conf{spool}/pids/$pid.stat");
					my $err = slurp("$conf{spool}/pids/$pid.err");
					if ($io_wait{$jid}->{status}) {
						$err = $io_wait{$jid}->{error} if ! -e "$conf{spool}/pids/$pid.err"; 
						$stat = $io_wait{$jid}->{status} if ! -e "$conf{spool}/pids/$pid.stat"; 
					}
					sockresp($io_wait{$jid}->{sock}, $stat->{status}, $err);
					unlink "$conf{spool}/pids/$pid.stat";
					unlink "$conf{spool}/pids/$pid.err";
					unlink "$conf{spool}/jpids/$jid";
				}
				delete $io_wait{$jid};
			}
		}
	}

	# assure we can't flood on misconfig
	$conf{ping_secs} = 5 if $conf{ping_secs} == 0;
	if (time() > ($conf{lastpidtime}+$conf{ping_secs})) {
		opendir(D,"$conf{spool}/pids");
		while(my $kid = readdir(D)) {
			next unless /^\d/;

			# finished, notify submitter

			if ($kid =~ /\.stat$/) {
				if (fmodtime("$conf{spool}/pids/$kid") < (time()-$conf{ping_secs})) {
					if (notifystat($kid)) {
						touch("$conf{spool}/pids/$kid");
					}
				}
				next;
			}
			# running, check status
			if ($kid =~ /^\d+$/ ) {
				my ($ret, $status, @rd) = waitusage($kid, WNOHANG);
				$status = undef if !$ret;
				my $alive = kill(0, $kid);
				#print "RET $ret STAT $status ALIVE $alive\n";
				if (writestat($kid, $status, $alive, undef, \@rd)) {
					notifystat($kid);
				}
			}
		}
		closedir D;

                opendir(D,"$conf{spool}/jpids");
                while(my $jid = readdir(D)) {
			next unless /^\d/;

			# no xio requests, and no stats in a long time...
			if ($conf{expire_secs} && ($conf{loop_num} > 2) && (stat("$conf{spool}/jpids/$jid"))[9] < time()-$conf{expire_secs}) {
				# and not running
				my $pid = slurp("$conf{spool}/jpids/$jid");
				if (! -e "$conf{spool}/pids/$pid") {
					xlog("error", "Expiring i/o for $jid ($pid)");
					unlink "$conf{spool}/jpids/$jid";
					unlink "$conf{spool}/stdio/$pid.err";
					unlink "$conf{spool}/stdio/$pid.out";
				}
			}
		}

		# cleanup any leftovers
		opendir(D,"$conf{spool}/stdio");
		while(my $kid = readdir(D)) {
			next unless /^(\d+)/;
			$kid = $1;
			if (! -e "$conf{spool}/pids/$kid.stat") {
				xlog("error", "Cleanup leftover err/out for $kid");
				unlink "$conf{spool}/stdio/$kid.err";
				unlink "$conf{spool}/stdio/$kid.out";
			}
		}
		closedir(D);

		$conf{lastpidtime} = time();
	}
}

sub touch {
	my $nowisthe=time();
	return utime($nowisthe, $nowisthe, @_);
}

sub fmodtime {
	return (stat($_[0]))[9];
}

sub notifystat {
	my ($kid) = @_;
	$kid =~ s/.stat$//;
	my $info = funpack("$conf{spool}/pids/$kid");

	if (!$info->{ip}) {
		if (unlink("$conf{spool}/pids/$kid.stat")) {
			xlog("error", "Orphaned job status file $kid");
		}
		return;
	}
	
	my $jid = $info->{id};

	# tell scheduler the status

#	print STDERR "HERE I AM NOTIFYING MASTER: " . Dumper($info);
	funpack("$conf{spool}/pids/$kid.stat", $info);
	xlog("debug", "Notifying status " . Dumper($info) . ".\n") if ($conf{trace} || $info->{trace});

	# for multi-master-scheduling, need to get the master ip & port from the INFO 

	# info should contain id, status, pid, an i/o wait flag and other rusage stats
	$info->{pid} = $kid;
	my $sock = _sendcmd($conf{master}, $conf{master_port}, 'jstat', %$info);

	$read_set->add($sock) if $sock;

	if (!$info->{jrun}) {
		# ok, i'm not running
		# release stdio/stat
		if ($io_wait{$jid}) {
			$io_wait{$jid}->{pid} = $kid;
			$io_wait{$jid}->{time} = time();		# how long you have to pickup i/o
		}
	}
}

sub writestat {
	my ($kid, $stat, $jrun, $err, $ru) = @_;
	if ( -e "$conf{spool}/pids/$kid" ) {
		if ($err && ! -e "$conf{spool}/stdio/$$.err") {
			burp("$conf{spool}/stdio/$$.err", $err);
		}
		open(ST, ">$conf{spool}/pids/$kid.stat") || return 0;
		print(ST "status:$stat\n");
		print(ST "jrun:1\n") if $jrun;
		print(ST "error:$err\n") if $err;
		if (@$ru) {
			xlog("debug", "Stats $kid: @$ru");
			print(ST "utime:$ru->[0]\n");
			print(ST "stime:$ru->[1]\n");
			print(ST "maxrss:$ru->[2]\n");
			print(ST "majflt:$ru->[5]\n");
			print(ST "inblock:$ru->[7]\n");
			print(ST "outblock:$ru->[8]\n");
			print(ST "msgsend:$ru->[9]\n");
			print(ST "msgrecv:$ru->[10]\n");
		}
		return close ST;
	}
	return 1;
}

sub gpack {
	my $msg;
	for (my $i=0;$i<@_;$i+=2) {
		$_[$i+1] =~ s/\n/ /g;
		$msg .= $_[$i] . ":" . $_[$i+1] . "\n";
	}
        return $msg;
}

sub funpack {
        my ($fil, $dat) = @_;
	return gunpack(slurp($fil), $dat);
}

sub gunpack {
	my ($msg, $dat) = @_;
	$dat = {} if !$dat;
	for (split(/\n/, $msg)) {
                my ($k, $v) = m/^\s*([^:]+)?\s*:\s*(.*?)\s*$/;
                $k = lc($k);
		$dat->{$k}=$v;
	}
	return $dat;
}

sub readconf {
        %conf = %def;

	_readconf("$conf{config}");

        # defines happen at the end so defaults can get unpacked
        for (keys %conf) {
		next if ref $conf{$_};
		if ($_ eq 'match') {
			# match rules are evaluated during matching, but reval now just to test
			my $test = $conf{$_};
			# see http://www.perlmonks.org/?node_id=685699 for why this is OK
			$test =~ s/`[^`]+`/1/g;			# turn off backtics
			$test =~ s/system\([^\)]\)/1/g;		# turn off system calls
			$safe->reval($test);			# check syntax
			if ($@) {
				# report a problem with the rule
				xlog("error", "Error testing match rule : $@");
			}
			$@='';
		} elsif ( ! ($conf{$_} =~ s/^\{(.*)\}$/eval($1)/gei) ) {
			# evaluate simple inline vars at configure-time
                	$conf{$_} =~ s/\$([\w-]+)/$conf{lc($1)}?$conf{lc($1)}:$1/gei;
		}
        }

        # reorganize some conf vars into a hash
	for my $k (qw(services log_types)) {
		my $v;
		$v = $conf{$k};
		$conf{$k} = {};
		for (split(/[\s,]+/,$v)) {
			$conf{$k}->{$_} = 1;
		}
	}

	# stored as an array reference
	$conf{env} = [split(/[\s,]+/,$conf{env})] unless ref($conf{env}) eq 'ARRAY';

	# split up host/port
	$conf{port} = $1 if $conf{bind} =~ s/:(\d+)$//;
	# same for master (if different - has to be if there's a queue/exec on the same box)
	$conf{master_port} = $1 if $conf{master} =~ s/:(\d+)$//;
	$conf{master_port} = $conf{port} if !$conf{master_port};
}

sub _readconf {
	my ($f) = @_;
	%conf = %def;
	if (!open(CONF, $f)) {
		xlog("error", "Can't open '$f'");
		return;
	}
	while(<CONF>) {
		next if /^\s*#/;
		my ($k, $v) = m/^\s*([^:]+)?\s*:\s*(.*?)\s*$/;
		$k = lc($k);
		if ($k eq 'include') {
			_readconf($v);
		} else {
			$conf{$k} = $v;
		}
	}
}

sub fail {
        xlog("error", @_);
        croak @_;
}

sub xlog {
        my $m = join("\t", @_);
	my $class = $_[0];
	return unless $conf{log_types}->{$class};
        $m =~ s/\n/ /g;
        my $line = scalar(localtime) . "\t" . $m . "\n";
        my $log = $conf{"log_file"};
        if ($log && ! ($log eq '-')) {
                open LOG, ">>" . $log;
                print LOG $line;
                close LOG;
        } else {
                print $line;
        }
        return $line;
}

sub waitio {
    my $opts = shift @_ if ref $_[0];
    my $tries;
    while (1) {
	++$tries;
        my $sock = _sendcmd(@_);
        if (!$sock) {
                xlog("error","Can't send command", packcmd(@_));
                sleep(5);
		next;
        }
        my ($dat, $stat, $got) = ('', '', 0);
	my $err;
        while ($got<3) {
		my $buf = '';
		my %head;
		my $break = 0;
		do {
			$buf .= $dat;
			while ($buf =~ s/^([^\n]+?) *: *([^\n]*?) *\n//) {
				$head{$1}=$2;
			}
			if ($buf =~ s/^\n//) {
				$dat = $buf;
				$break = 1;
			}
		} while (!$break && $sock->sysread($dat, 4096));

		$err = $head{error} if $head{error};

#		print Dumper(\%head);
#		print "DAT IS: ($dat)\n";

		if (!$head{name}) {
			xlog("error", "Didn't get name: header ($tries)");
		}
		last if (!$head{name});

		my $statstr;  
		my $fh;

		if ($opts->{inplace} && (!$head{error})) {
			# inplace file retrieval
			my $dir = $head{name};
			$dir =~ s/[^\/]+$//;
			system("mkdir", "-p", $dir) if ! -e $dir;
			open($fh = new IO::File, '>', $head{name}); 
		} else {
			# stderr/out/stat 
			$fh = $head{name}=~/\.err$/ 
				? *STDERR
				: *STDOUT;

			$statstr = 1 if $head{name}=~/\.stat$/;
		}

		my $left = $head{len};

		++$got;
		do {
#			print STDERR "left: $left dat:" . length($dat) . "\n"; 
			if ($left>0) {
				if ($statstr) {
					$stat .= substr($dat,0,$left);
				} else {
					print $fh substr($dat,0,$left);
				}
				my $ldat = length($dat);
				substr($dat,0,$left) = '';
				$left -= $ldat;
			}
#			print STDERR "left: $left dat:" . length($dat) . "\n"; 
		} while ($left>0 && $sock->sysread($dat, 4096));

		if ($opts->{inplace}) {
			close $fh;
			$got = 3;
		}
	}

	if ($stat) {
		$stat = gunpack($stat);
		return ($stat->{status}, $stat->{error});
	} elsif ($err) {
		xlog("warn", "Error returned: $err, reporting status -2 for (@_)");
		return (-2, $err);
	} elsif ($opts->{inplace}) {
		return (0, '');
	} else {
		sleep(5)
	}
    }
}

sub waitmsg {
	my $sock = _sendcmd(@_);
	if (!$sock) {
                xlog("error", "Can't send command ", packcmd(@_));
		return ();
	}
	my ($buf, $dat);
	while ($sock->read($dat, 4096)) {
		$buf .= $dat;
	}
	if (substr($buf,-2,2) eq $EOT) {
		substr($buf,-2,2) = '';
		return unpackcmd($buf);
	}
	$@="Socket protocol error, no EOT ($.)";
	return ();
}

sub xsend {
	my $sock = _sendcmd($conf{master}, $conf{master_port}, @_);
	if ($sock) {
		close $sock;
		return 1;
	}
	return 0;
}

sub sendcmd {
	my $sock = _sendcmd(@_);
	return $sock ? close($sock) : undef;  
}

sub packcmd {
	return Data::Dumper->new([\@_])->Indent(0)->Terse(1)->Dump().$EOT;
}

sub packref {
	return Data::Dumper->new(\@_)->Indent(0)->Terse(1)->Dump();
}

sub unpackcmd {
	my $ref = $safe->reval($_[0]);
	if (ref($ref) eq 'ARRAY') {
		return @$ref;
	} else {
		eval{confess "Protocol error, packed array expected (@_), got $ref"};
               	xlog("error",$@);
		return ();
	}
}

sub _sendcmd {
	my ($host, $port, @cmd) = @_;
	my $xcmd = packcmd(@cmd);
        my $sock = IO::Socket::INET->new(Proto=>"tcp",PeerPort=>$port,PeerAddr=>$host, Timeout=>5);
        if (!$sock) {
                xlog("error",$@="Can't connect to $host:$port", Carp::longmess());
		return undef;
        }
        if ($sock->send($xcmd)) {
		return $sock;
	}
}

sub burp
{
        my ($f, $dat) = @_;
        my $h = new IO::File;
        open ($h, ">$f");
        print $h $dat;
        close $h;
}

sub usage {
	my $u;
	$u .= <<'EOF';
Usage: grun <exec-options> command...
   or: grun -d [<local-daemon-options>]
   or: grun -k <jobid>
   or: grun -e <jobid> key val
   or: grun -q [<query-options>] <query-command>

Lightweight job queueing system

For more help, run grun -?, grun -d -?, grun -C -? or grun -q -?.
EOF

	$u .= <<'EOF' unless $daemon || $qinfo;

Execution Options:
    -f|ile FILE     Read FILE for job options
    -t|race         Trace mode (verbose logging)

    -m|em INT       memory minimum in MB
    -c|pu CPUS	    minimum number of cpus 
    -host N1,N2     specify certain hosts
    -j|obid TEXT    secondary job ID
    -v|erbose       send job id, execution node and stats to STDERR

    -noio           disable io-processing, but wait for completion
    -nowait         no io and don't wait, just start the command
    -e|rr FILE      write stderr directly to FILE, no spool
    -o|ut FILE      write stdout directly to FILE, no spool

If the command contains shell metacharacters, it's prefixed with "bash -c".
EOF

	$u .= <<'EOF' if $qinfo;

Query Options:
    -a|ll           Query all nodes
    -n|odes         ($master) List of nodes to query

Query Commands:
    [-]status       List nodes (q)
    [-]jobs         List jobs (q)
    [-]history      List prior jobs (q)
    [-]conf         Dump config from memory (q,e)
EOF

	$u .= <<'EOF' if $daemon;

Daemon Options:
    -h|osts         (local) One or more hosts
    -r|eload        Reload config
    -k|ill          Kill running server
    -R|ESTART       Kill and restart a running server

Without an option, -d just starts the daemon on the local machine.
EOF

	$u .= <<'EOF';

Common Options:
    -C FILE         (/etc/grun.conf) Config file location
    -t|race         Turn on debugging in the log file
    -v|ersion       Print version and exit
    -?              Show this help page
EOF

	$u .= <<'EOF' if defined $config;

Configuration File:

All config variables written as {value} are interpreted as perl code, and get evaluated at startup.

The "include" varialbe actually just includes the file specified, as if it were part of the original file.

All non-code configuration variables can include '$varname', which gets expanded to the value of another config var.

Be careful with match code.  It it's slow, it will kill the performance of your main node.

Common variables:

    master          (localhost) Hostname[:port] of master node
    spool           (/var/spool/grun) Location for queue & io temp storage
    log_file	    Location of the log
    services        Must be 'queue' and/or 'exec'
    port            Port to listen on (5184)
    bind[:port]     Address to bind to (0.0.0.0)
    trace           Turn tracing on for the whole server

Queue config vars:

    env             (PATH) List of environment varialbes to copy to the processes.  An asterisk (*) means 'ALL'
    expire_secs     (0) If set, jobs that aren't pinged in time get (failed or retried)
    expire_action   (retry) Can be 'retry', 'fail'
    idle_load	    (.3) If load is less than this amount, then considered idle
    io_keep	    (3600) Time to keep unretrieved stdio files (0=forever)
    log_file        Where to send "xlog" output
    pid_file	    (/var/run/grun.pid)
    ping_secs       (30) Nodes ping the master this often.
    ping_expire     (2*$ping_secs) Drop a node if it doesn't ping in time

Execution node config vars:

    match           Perl code that must eval to TRUE for a node match
    full_match      (1) If jobs queue is full, this is evaluated
    full_exec       If full match returns true, then this command is run
    wrap            Job command wrapper
    
EOF
   return $u;
}

sub showconf {
	return Data::Dumper->new([\%conf])->Sortkeys(1)->Indent(1)->Terse(1)->Dump().$EOT;
}

sub showhist {
	my %opt;

	$opt{fmt} = '%jid\t%user\t%stat\t%cwd\t%cmd\t%host\t%mtime\n';

        {
                local @ARGV = @_;
                GetOptions(\%opt, "count|c=i", "user=s","job=i","resubmit","fmt|F=s","long","grep|g=s");
                @_=@ARGV;
        }
	if ($_[0] =~ /[a-z]/ && !$opt{user}) {
		$opt{user} = $_[0]
	} elsif ($_[0] =~ /^\d+$/) {
                $opt{job} = $_[0]
        }
        my $r;
	
	my $mx = -1;
        opendir(D,"$conf{spool}/jhist");
	while(defined ($_=readdir(D))) {
		next unless /^\d+$/;
		if ($_ > $mx) {
			$mx = $_;
		}
	}
	closedir(D);

        opendir(D,"$conf{spool}/jhist/$mx");
	my @D = sort {$b-$a} readdir(D);
	closedir(D);

	my $count = $opt{count}; 
	$count = 50 if !$count;

	splice @D, $count*1.4 unless $opt{user}||$opt{grep};
	
        for my $jid (@D) {
                my $f = "$conf{spool}/jhist/$mx/$jid";
		my $mtime = (stat($f))[9];
                next unless -f $f;
                my @job=unpackcmd(slurp($f), 1);
                my ($job, @cmd) = @job;
                if (ref($job)) {
			next if $opt{user} && ! ($job->{user} eq $opt{user});
			next if $opt{grep} && "$job->{user}\t@cmd\t$job->{cwd}" !~ $opt{grep};
			--$count;
                        my %job=%{$job};

			$job{status} = 'OK' 		if $job{status} eq 0;
			$job{status} = 'INT' 		if $job{status} eq 2;
			$job{status} = 'ORPHAN' 	if $job{status} eq -8;
			$job{status} = 'NOTFOUND' 	if $job{status} eq 32512;
			$job{status} = 'TERM' 		if $job{status} eq 15;
			$job{stat} = $job{status};

			my $cmd = join(' ', @cmd);
			$cmd =~ s/\n\s+/\n/g;
			$cmd =~ s/^\s+//;
			$cmd =~ s/\s+$//;
			$cmd =~ s/\n/;/g;
			if ($nodes{$job{host}}->{hostname}) {
				$job{host}=$nodes{$job{host}}->{hostname} 
			} elsif (-e (my $n="$conf{spool}/nodes/$job{host}.reg")) {
				my @node=unpackcmd(slurp($n), 0);
				$job{host}=$node[1]->{hostname};
			}
			$job{jid}=$jid;
			$job{cmd}=$cmd;
#			$job{env}=join ':' . map { $_.'='.$job{env}{$_} } keys %{$job{env}};
			$job{mtime}=fmtime($mtime);
			if (ref($job{usage})) {
				for (keys(%{$job{usage}})) {
					$job{$_}=$job{usage}{$_};
				}
			}
			if ($opt{long}) {
				$opt{fmt} = '----------\n';
				for(sort(keys(%job))) {
					$opt{fmt} .= "$_=" . '%' . $_. '\n';
				}
			}
	
			$r .= fmtstr($opt{fmt}, \%job);
                }
		last if $count == 0;
        }
        return $r;
}

sub fmtime {
	my ($t) = @_;
	return strftime("%m/%d %H:%M",localtime($t));
}

# grun -q status
sub shownodes {
        my $r;
        $r .= sprintf "%-15s %9s %5s\n", 'Hostname','Memory', 'Cpu';
	my @nodes = getnodes();
        for my $node (sort {$a->{hostname} cmp $b->{hostname}} @nodes) {
                if ($node->{ping} > time() - ($conf{ping_secs} * 2) ) {
                        $node->{hostname} = substr($node->{hostname},0,15);
                        chomp($node->{hostname});

			my $cpus = $node->{cpus} - $node->{a_cpus};
			$cpus = $node->{avail} if $node->{avail} < $cpus;

			my $mem = $node->{tmem} - $node->{a_memory};
			$mem = $node->{mem} if $node->{tmem} > 0 && $node->{mem} < $mem;

			if ($node->{tmem} > 0) {
	                        $r .= sprintf "%-15s %8dm/%d %5.1f/%d\n", $node->{hostname}, $node->{mem}/1000, $node->{tmem}/1000,$node->{avail},$node->{cpus};
			} else {
	                        $r .= sprintf "%-15s %8dm %5.1f/%d\n", $node->{hostname}, $node->{mem}/1000, $node->{avail},$node->{cpus};

			}
                }
        }
        return $r;
}

# grun -q jobs
sub showjobs {
	my %opt;

	$opt{fmt} = '%s:jid\t%s:user\t%s:stat\t%s:cwd\t%s:cmd\n';
	{
		local @ARGV = @_;
		GetOptions(\%opt, "dump", "user=s","job=i","fmt|F=s");
		@_=@ARGV;
	}

	if (@_ == 1) {
		my $user = shift @_;	
		if ($user =~ /^\d+$/) {
			$opt{job}=$user;
		} else {
			$opt{user}=$user if !($user eq '');
		}
	}

	xlog("debug", "Show job for user: $opt{user}, $opt{job}\n");

        my $r;
#        $r .= sprintf "%s\t%s\t%s\t%s\t%s\n", 'JobID','User','Host','Cwd','Command';


        opendir(D,"$conf{spool}/jobs");
        while(my $jid=readdir(D)) {
		next if $jid =~ /\.ip$/;
                my $f = "$conf{spool}/jobs/$jid";
                next unless -f $f;
                my @job=unpackcmd(slurp($f));
                my ($job, @cmd) = @job;
		if (ref($job)) {
			my %job=%{$job};
			next if $opt{user} && ! ($opt{user} eq $job{user});
			next if $opt{job} && ! ($opt{job} eq $jid);
			my $stat = '(I)';
			if ($jid =~ s/:([.\d]+?)\.run$//) {
				my $ip = $1;
				my @node = unpackcmd(slurp("$conf{spool}/nodes/$ip.reg"));
				if (ref($node[1])) {
					$stat = $node[1]->{hostname}; chomp $stat;
				}
			}
			# trim for display
			for (@cmd) {
				s/^\s+//g;
				s/\n\s*/;/g;
			}
                        $job->{jid} = $jid;
                        $job->{stat} = $stat;
                        $job->{cmd} = join(' ', @cmd);
			if ($opt{dump}) {
				$r .= packdump($job) . "\n";
			} else {
				$r .= fmtstr($opt{fmt}, $job);
			}
		}
        }
        closedir(D);
        return $r;
}

sub fmtstr {
        my ($fmt, $hash) = @_;
        my @fds = $fmt =~ m/%(?:[#0 +,I:-]*(?:\d+)?(?:\.\d+)?\w+:)?(\w+)/g;
        my @vals = map $hash->{$_}, @fds;
        $fmt =~ s/(%[#0 +,I:-]*(?:\d+)?(?:\.\d+)?\w{1,2}):\w+/$1/g;
	my $fds=join '|', @fds;
        $fmt =~ s/%($fds)/%s/g;
        $fmt = $safe->reval('"' . $fmt . '"');
        return sprintf($fmt, @vals);
}

sub bestunique {
	my ($c, @c)  = @_;
	my $b;
	for (@c) {
		if ($_ =~ /^$c/) {
			return undef if ($b);
			$b = $_;
		}
	}
	return $b;
}

# returns an array of [host,port], given a list of host[:port] names
sub expandnodes {
	my @r;
	my @n;
	for (split(/[\s,]/, join ' ', @_)) {
		my ($h, $p) =  m/^(.*)(:\d+)?$/;
		$p = $conf{port} if !$p;
		if ($h =~ s/\*/\.\*/g) {
			if (!@n) {
				@n=getnodes();	
			}
			for (@n) {
				push @r, [$_->{hostname}, $p] if $_->{hostname} =~ /$h/;
			}
		} else {
			push @r, [$h, $p];
		}
	}
	return @r;
}

sub evalctx {
	my ($expr, @ctx) = @_;
	my $msafe = new Safe;
	$msafe->permit(qw(:subprocess));        # allow backticks
	for(my $i = 0; $i < @ctx; $i+=2) {
		my ($name, $var) = ($ctx[$i], $ctx[$i+1]);
		# references to hashes/arrays become dereferenced hashes/arrays
		if (ref($var) eq 'HASH') {
			%{$msafe->varglob($name)}=%{$var};
		} elsif (ref($var) eq 'ARRAY') {
			@{$msafe->varglob($name)}=@{$var};
		} else {
			${$msafe->varglob($name)}=$var;
		}
	}
	$msafe->share(qw(%conf %ENV));
#	if ($conf{trace}) {
#		xlog("debug", "Evaluating {$expr}\n");
#	}
	my ($res, @res);
	if (wantarray) {
		@res = $msafe->reval($expr);
	} else {
		$res = $msafe->reval($expr);
	}
	my $save = $@;
	if ($@) {
		xlog("error", "Error evaluating {$expr} : $@\n");
		return undef;
	}
	$@=$save;
	if (wantarray) {
		return @res;
	} else {
		return $res;
	}
}

sub kicknodes {
        my @nodes = getnodes(cached=>1);
	return if !$conf{kickstart};
        return if (time() < ($conf{lastkicktime} + $conf{ping_secs} * 4));
	$conf{lastkicktime} = time();
	for my $node (@nodes) {
		# sometime in the last 24 hours?
		if ($node->{ping} > (time() - ($conf{remove_secs}))) {
			# but not in the last couple minutes
			if ($node->{ping} < (time() - ($conf{ping_secs} * 4)) ) {
				# kick it
				xlog("note", "Kicking node $node->{hostname}\n");
				if (fork) {
					my $cmd = $conf{kickstart};
					if ($cmd =~ /^\{(.*)\}$/) {
						$cmd = evalctx($1, node=>$node);
					}
					if ($cmd && $cmd !~ /\$/) {
						exec("$cmd");	
					}
				}
			}
		}
	}
}

sub getnodes {
	my (%opt) = @_;
	my @r;
	if (!$opt{cached} && %nodes) {
		# return memcached values
		return values %nodes;
	}
	# read all from disk, including old ones
        opendir(D,"$conf{spool}/nodes");
        while($_=readdir(D)) {
                $_ = "$conf{spool}/nodes/$_";
                next unless -f $_;
                my @node=unpackcmd(slurp($_));
		if (! defined $node[1]->{avail}) {
			$node[1]->{avail} = $node[1]->{cpus}-$node[1]->{load};
		}
                push @r, $node[1];
	}
	closedir D;
	return @r;
}

sub startdaemon {
	my ($dkill, $restart, $reload, $node, $all);

	GetOptions("kill"=>\$dkill, "RESTART"=>\$restart, "reload"=>\$reload, "host=s"=>\$node, "all"=>\$all) ||
		die usage();

	$node = '*' if $all;

	if ($reload || $node) {
		my @n = $node ? expandnodes($node) : ([$conf{master},$conf{master_port}]);
	
		my $stat = 0;
		my $xcmd = $reload ? 'relo' : $restart ? 'rest' : $dkill ? 'term' : '';
		if (!$xcmd) { 
			die usage();
		}
		for (@n) { 
			my ($res) = waitmsg($_->[0], $_->[1], "xcmd", $xcmd);
			if (! defined $res) {
				print "$@\n";
				$stat = 1;
			} else {
				print "$res\n";
			}
		}
		exit $stat;
	}

	if ($restart) {
		$daemon = 1;
	}

	killgpid() if $dkill || $restart;
	exit 0 if $dkill;
	sleep 1 if $restart;

	# start daemon
	if ($gpid) {                                             # already running?
		if (kill(0, $gpid)) {
			die "Already running ($gpid), not starting twice\n";
		}
	}
	xlog("note", "Starting daemon as " . getpwuid($<));

	if (!($gpid=fork)) {
		die "Can't fork child process\n" if (! defined $gpid);

		open (P, ">$conf{pid_file}") || die "Can't open pidfile '$conf{pid_file}' : $!\n";
		print P $$;
		close P;                                        # save pid

		open STDIN,  '</dev/null';
		if (! -t STDOUT || ( $conf{log_file} && ! ($conf{log_file} eq '-'))) {
			open STDOUT, '>/dev/null';
			open STDERR, '>&STDOUT';
		}

		chdir '/';

		POSIX::setsid();

		$SIG{INT}  = sub {close $listener; $quit = 1};
		$SIG{TERM} = $SIG{INT};
		$SIG{HUP}  = \&init;

		$listener = IO::Socket::INET->new(Proto=>"tcp",LocalPort=>$conf{port}, LocalAddr=>$conf{bind}, Reuse=>1, Timeout=>1, Listen=>100)
		  or die "Can't make TCP server on port $conf{port}: $@";
		$read_set = new IO::Select();
		$write_set = new IO::Select();
		$read_set->add($listener);
		$quit = 0;
		$conf{loop_num} = 0;
		while (!$quit) {
			++$conf{loop_num};
			eval {readsocks()};
			last if $quit;
			xlog("error", "Daemon readsocks exception: $@") if $@;

			# theoretically these could be in separate threads, or forked off
			if ( $conf{services}->{queue} ) {
				eval {schedule()};
				xlog("error", "Daemon schedule exception: $@") if $@;
			}
			if ( $conf{services}->{exec} ) {
				eval {srvexec()};
				xlog("error", "Daemon srvexec exception: $@") if $@;
			};
		}
		select(undef, undef, undef, 0.1);
		xlog("note", "Shutdown");
		unlink $conf{pid_file};
	}
	exit 0;
}

sub killgpid {
	die "Can't find pid $conf{pid_file} for daemon\n" if !$gpid;
	if (!kill(2, $gpid)) {
		die "Can't kill -INT $gpid: $!\n";
	}
	$gpid = 0;
}

sub samehost {
	my($h1, $h2) = @_;
	$h1=host2ip($h1);
	$h2=host2ip($h2);
	# localhost = dig `hostname`
	$h1 =~ s/^(0\.0\.0\.0|127\.0\.0\.1)$/$conf{hostip}/;
	$h2 =~ s/^(0\.0\.0\.0|127\.0\.0\.1)$/$conf{hostip}/;
	return $h1 eq $h2;
}

sub host2ip {
  my (@octets, $raw_addr, $ip);
  return $_[0] if $_[0] =~ /^(\d+\.){3}\d+$/;
  $raw_addr = (gethostbyname($_[0]))[4];
  @octets = unpack("C4", $raw_addr);
  $ip = join(".", @octets);
  return($ip);
}

sub packdump {
	Data::Dumper->new(\@_)->Indent(0)->Sortkeys(1)->Terse(1)->Dump();
}

sub kill_job {
	my ($killjob, $sig) = @_;
        my ($err) = waitmsg($conf{master}, $conf{master_port}, 'jkill', $killjob);
        if ($err =~ /Forward:?\s*([\d.]+):?(\d*)/) {
                my ($ip, $port) = ($1, $2);
                $port = $conf{port} if !$port;
                # this is WRONG ... messages should all have trace bits... that would be nice
                sendcmd($ip, $port, 'trace', 1) if ($conf{trace});
                ($err) = waitmsg($ip, $port, 'xabort', $killjob, $sig);
		if ($err =~ /(Not Found)|(Inappropriate ioctl for device)/i) {
        		waitmsg($conf{master}, $conf{master_port}, 'jkill', $killjob, $ip);
		}
                sendcmd($ip, $port, 'trace', 0) if ($conf{trace});
        }
	return $err;
}

# if wait3 and a C compiler is available, it also returns 
# the rusage stats in order of the structure (man getrusage)
my $wait_loaded;
sub waitusage {
	if (!defined($wait_loaded)) {
		eval {
			require Inline;
			my $code = <<EOF;
#include <sys/wait.h>

#define MORTPUSH(x) Inline_Stack_Push(sv_2mortal(x))

void _waitru(int pid, int opts) {
	int st=-9;
	struct rusage r;
	Inline_Stack_Vars;

	if (pid == -1) {
		pid=(int)wait3(&st, opts, &r);
	} else {
		pid=(int)wait4(pid, &st, opts, &r);
	}

	Inline_Stack_Reset;

	MORTPUSH(newSViv(pid));
	MORTPUSH(newSViv(st));
	MORTPUSH(newSVnv((double) r.ru_utime.tv_sec + ((double) r.ru_utime.tv_usec)/1000000.0 ));
	MORTPUSH(newSVnv((double) r.ru_stime.tv_sec + ((double) r.ru_stime.tv_usec)/1000000.0 ));
	MORTPUSH(newSViv(r.ru_maxrss));
	MORTPUSH(newSViv(r.ru_ixrss));
	MORTPUSH(newSViv(r.ru_idrss));
	MORTPUSH(newSViv(r.ru_isrss));
	MORTPUSH(newSViv(r.ru_minflt));
	MORTPUSH(newSViv(r.ru_majflt));
	MORTPUSH(newSViv(r.ru_inblock));
	MORTPUSH(newSViv(r.ru_oublock));
	MORTPUSH(newSViv(r.ru_msgsnd));
	MORTPUSH(newSViv(r.ru_msgrcv));
	MORTPUSH(newSViv(r.ru_nsignals));
	MORTPUSH(newSViv(r.ru_nvcsw));
	MORTPUSH(newSViv(r.ru_nivcsw));
	
	Inline_Stack_Done;
}
EOF
			Inline->bind(C => $code);
		};
		if ($@) {
			warn "$@\n";
		}
		$wait_loaded = $@ ? 0 : 1;
	}
	if ($wait_loaded) {
		return _waitru(@_);
	} else {
		my $pid = waitpid($_[0], $_[1]);
		my $st = $?;
		return ($pid, $st);
	}
}	
