#!/usr/bin/perl

#    grun - lightweight jobs queueing system
#    Copyright (C) 2011 Erik Aronesty
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

use Carp;
use Getopt::Long qw(GetOptions);
use Data::Dumper;
use IO::Socket;
use IO::Select;
use IO::File;
use POSIX ":sys_wait_h";
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Safe;
use Cwd;

our $VERSION = 0.8.95;				# 0.9 will be feature lock.   1.0 will be config backward lock

my $WIN32 = ($^O =~ /Win32/);
my $EOT = pack("cc",0,4);
my $SOCK_WAIT = -1;				# wait for resp
my $SOCK_FILE = -2;				# send files over socket
 
my ($daemon, $killjob, $editjob);
my (%conf, %def);

# defaults just run things locally, no master
$def{config} = "/etc/grun.conf";		# config file
$def{spool} = "/var/spool/grun";		# dir to place jobs
$def{port} = 5184;				# listen/connect port
$def{bind} = '0.0.0.0';				# listen addr
$def{env} = ['PATH'];				# list of environment vars to copy from submit through to exec
$def{ping_secs} = 30;				# how often to tell about load/mem/stats
$def{remove_secs} = '$ping_secs * 1000';	# don't even try kickstarting if the node is this old
$def{idle_load} = .3;				# how often to tell about load/mem/stats
$def{retry_secs} = 60;				# how often to retry notifications
$def{io_keep} = 3600;				# keep io for this long after a job with i/o is finished in a detached session
$def{sched_secs} = '1';				# how often to try scheduling
$def{master} = 'localhost:5184';		# central scheduler
$def{services} = {queue=>1, exec=>1};		# all can run
$def{pid_file} = "/var/run/grun.pid";		# pid file
$def{log_file} = "/var/log/grun.log";		# pid file
$def{hostname} = $ENV{HOSTNAME} ? $ENV{HOSTNAME} : $ENV{COMPUTERNAME} ? $ENV{COMPUTERNAME} : `hostname`;
chomp $def{hostname};

my ($qinfo, $help, $config);

Getopt::Long::Configure qw(require_order no_ignore_case passthrough);
GetOptions("daemon"=>\$daemon, "CONF:s"=>\$config, "trace"=>\$def{trace}, "query"=>\$qinfo) ||
	die usage();

if ($ARGV[0] eq '-?') {
	shift @ARGV;
	$help = 1;
}

$def{config} = $config if $config;

$help = 1 if defined $config && !$config;

if ($help) {
	print usage();
	exit 0;
}

if (!$daemon) {
	# -k <id> works as long as -d wasn't specified
	GetOptions("kill=i"=>\$killjob, "trace"=>\$def{trace}, "edit"=>\$editjob) ||
		die usage();
}

my $safe = new Safe;

init();

my $gjobid = slurp("$conf{spool}/nextid");

if ($qinfo) {
	# this is the code for grun -q

	Getopt::Long::Configure qw(no_require_order no_ignore_case passthrough);
	my %opt;
	GetOptions(\%opt, "count=i", "silent", "inplace", "hosts=s") || die usage();
	my $cmd = shift @ARGV;
	die usage() if !$cmd;

	my @arg = @ARGV;
	$cmd =~ s/^-//;
	my $tmp = substr bestunique($cmd, qw(config status jobs file history)), 0, 4;
	if (!$tmp) {
		die "Command $cmd is not available, for help type grun -query -?\n";
	}
	$cmd = $tmp;

	# some commands default to localhost, others default to queue host... this is confusing... fix?

	my @dest = $opt{hosts} ? expandnodes($opt{hosts}) : 
		$cmd eq 'conf' ? [$conf{bind}, $conf{port}] : 
		[$conf{master},$conf{master_port}];

	if ($cmd eq 'file' && @dest > 1) {
		die "Command $cmd cannot be run on multiple hosts";
	}

	for my $d (@dest) {
	my ($host, $port) = @$d;

	if ($conf{trace}) {
		sendcmd($host, $port, 'trace', 1);
	}

	if ($cmd eq 'file') {
		my $cwd = cwd;
		my @need;
		for (@arg) {
			next if -e $_;
			if ($_ !~ /^\//) {
				$_ = "$cwd/$_";	
			}
			push @need, $_;
		}
		if (@need) {
			my ($res, $error) = waitio({inplace=>$opt{inplace}}, $host, $port, "xcmd", $cmd, @need);
			die $error, "\n" if $error && !$opt{silent};
			exit 1 if $error;
		}
	} elsif (!samehost($host,$conf{bind}) || (!$ENV{_GRUN} && (!$conf{services}->{queue} || $cmd =~ /^conf|stat$/))) {
		# this could get ugly, if called a lot, may want to make more efficient
		my ($res) = waitmsg($host, $port, "xcmd", $cmd, @arg);
		print $res;
	} else {
		if ($cmd eq 'stat') {
			print shownodes(@arg);
		}	
		if ($cmd eq 'jobs') {
			print showjobs(@arg);
		}	
		if ($cmd eq 'hist') {
			print showhist(%opt);
		}	
	}
	}
	exit 0;
}

my $gpid;						# daemon pid
if (open(IN, $conf{pid_file})) {
	$gpid = <IN>;
	close IN;
}

if ($killjob) {
	# grun -k code
	my $sig = 2;
        GetOptions("signal=i"=>\$sig) || die usage();
	if ($conf{trace}) {
                sendcmd($conf{master}, $conf{master_port}, 'trace', 1);
	}
	my ($err) = waitmsg($conf{master}, $conf{master_port}, 'jkill', $killjob);
	if ($err =~ /Forward:?\s*([\d.]+):?(\d*)/) {
		my ($ip, $port) = ($1, $2);
		$port = $conf{port} if !$port;
		# this is WRONG ... messages should all have trace bits... that would be nice
		sendcmd($ip, $port, 'trace', 1) if ($conf{trace});
		($err) = waitmsg($ip, $port, 'xabort', $killjob);
		sendcmd($ip, $port, 'trace', 0) if ($conf{trace});
		if (!defined($err) && $@) {
			die $@,"\n";
		}
	}
	my $ok = ($err =~ /^Job.*aborted/);
	warn "$err\n" if $ok; 
	$err = 'No response to jkill' if !$ok && !$err;
	die "Error: $err\n" if !$ok;
	exit 0;
}

if ($editjob) {
        my ($err) = waitmsg($conf{master}, $conf{master_port}, 'jedit', @ARGV);
        my $ok = ($err =~ /^Job.*edited/);
        warn "$err\n" if $ok;
	$err = 'No response to jedit' if !$ok && !$err;
        die "Error: $err\n" if !$ok;
        exit 0;
}

my ($listener, $read_set, $write_set, $quit, %io_wait, %run_wait);	# daemon globals

if ($daemon) {
	startdaemon();
	exit 0;
}

####################
# client mode

my %nodes;
my %jobs;
my %opt;

$opt{wait} = 1;				# keep socket open until job is finished
$opt{io} = 1;				# copy io back on the socket, implies wait

Getopt::Long::Configure qw(require_order no_ignore_case passthrough);
GetOptions(\%opt, "file=s", "memory=i", "hosts=s", "cpus=i", "io!", "wait!", "ferr=s", "fout=s", "kill=i");

while ($ARGV[0] =~ /^--([\w-]+)=([\w=]+)/) {
	# allow arbitrary job options, that jan later be referred to in match expressions
	# or in execution wrappers, etc
	$opt{$1} = $2;
	shift @ARGV;
}

if ($ARGV[0] =~ /^-/) {
	die "Unknown option $ARGV[0]\n";
}

my @cmd = @ARGV;

if ($opt{file}) {
	# read options from a file
	funpack($opt{file}, \%opt);
	if ($opt{cmd}) {
		if (@ARGV) {
			die "Can't supply cmd: in the file and '@cmd' on the command line\n";
		}
		if ($opt{cmd} !~ /^[\w0-9:\/\t -]+$/) {
			# not simple: let bash handle it
			@cmd = ('bash', '-c', $opt{cmd});
		} else {
			# simple: split, pass as is to exec
			@cmd = split / /, $opt{cmd};
		}
	}
}

if ($opt{memory}) {
	$opt{memory} *= 1000;
	if ($opt{memory} =~ /gb?$/) {
		$opt{memory} *= 1000;
	}
	if ($opt{memory} =~ /kb?$/) {
		$opt{memory} /= 1000;
	}
}

if ($conf{auto_profile}) {
	if (-e ($conf{auto_profile})) {
		my $cmd = join ' ', @cmd;
		# safe'ish eval, just so there aren't weird side effects
		my ($cpu, $mem) = evalctx(slurp($conf{auto_profile}) . ";\nreturn (\$cpu, \$mem);", cmd=>$cmd, cmd=>\@cmd);
		$opt{memory}=$mem if ($mem > $opt{memory});
		$opt{cpus}=$cpu if ($cpu > $opt{cpus});
	}
}

if (!@cmd) {
	die usage();
}

# no socket io unless waiting
if (!$opt{wait}) {
	delete $opt{io};
}

# force exec in "same as current dir"
$opt{cwd} = cwd;

# copy env
for (@{$conf{env}}) {
	$opt{env}->{$_} = $ENV{$_} if defined $ENV{$_};
}

$opt{user} = getpwuid($>);
$opt{umask} = umask();

my %info;
my $interrupt;

sub sigh {
	my $signame = shift;
	if ($info{ip}) {
		print STDERR "Aborting command, sending xabort to $info{ip}\n";
		sendcmd($info{ip}, $info{port}, 'xabort', $info{jid});
		exit -1;
	} else {
		# for now, don't interrupt the initial message
		# later, when we have client-generated job id's this will go away
		$interrupt = $signame;
	}
};

$SIG{INT} = \&sigh;
$SIG{TERM} = \&sigh;

if ($conf{trace}) {
	$opt{trace} = 1;
	sendcmd($conf{master}, $conf{master_port}, 'trace', 1);
}

%info = waitmsg($conf{master}, $conf{master_port}, 'run', \%opt, @cmd);

if ($interrupt) {
	sigh($interrupt);
}

if (!%info) {
	die "$@\n";
}

if ($info{error}) {
	print STDERR $info{error}, "\n";
	exit -1;
}

if ($opt{wait}) {
	# look at all the work you can avoid if you don't wait
	my ($stat, $err);
	# connect to executing node directly and ask for stderr, stdout, and status based on job id
	while (!defined $stat && !defined $err) {
		# shadow watcher....
		if ($opt{io}) {
			($stat, $err) = waitio($info{ip}, $info{port}, 'xio', $info{jid});
		} else {
			($stat, $err) = waitmsg($info{ip}, $info{port}, 'xstat', $info{jid});
		}
		if ($stat == 65280 && !$err) {
			print STDERR "$cmd[0]: No such file or directory.\n";
		} 
		sleep 5 if (!defined $stat && !defined $err);
	}
	if (defined $stat) {
		# send this command into the ether...if exec doesn't get it, clean up after timeout
		if ($opt{io}) {
			sendcmd($info{ip}, $info{port}, 'xclean', $info{jid});
		}
	}
	if ($stat == 11) {
		$err = 'Segmentation fault';
	}
	if ($err) {
		print STDERR $err, "\n";
	}
	exit $stat>>8;
} else {
	# aah... nicer
	print STDOUT "Job id $info{jid}\n";
}

END {
	if (!$daemon && $conf{trace}) {
		sendcmd($conf{master}, $conf{master_port}, 'trace', 0);
	}
}

sub readsocks {
	# based on ppcgid, nonforking socket code

    	my ($new_readable, $new_writable, $new_error) = IO::Select->select($read_set, $write_set, $read_set, 1);

	# if the thing you're doing is slowing that forking... fork
	foreach my $sock (@$new_readable) {
		if ($sock == $listener) {
			my $new_sock = $sock->accept();
			if ($new_sock) {
			    if ($WIN32) {
				ioctl($new_sock, 0x8004667e, pack("I", 1));
			    } else {
				fcntl($new_sock, F_SETFL, O_NONBLOCK);
			    }
			    $read_set->add($new_sock);
			    *$new_sock{HASH}->{time} = time();
			}
		} else {
			my $buf;
			my $bytes_read = sysread($sock, $buf, 4096);

			if (substr($buf,-2,2) eq $EOT) {
				substr($buf,-2,2) = '';
				$buf = *$sock{HASH}->{buf}.$buf;
				my @resp = process_message($buf, $sock);
				delete *$sock{HASH}->{buf};
				if (!@resp) {
					xlog("debug", "Closing $sock sock after EOT\n") if $conf{trace};
					close_sock($sock);
				} elsif ($resp[0] eq $SOCK_WAIT) {
					xlog("debug", "Setting $sock to wait mode\n") if $conf{trace};
					# leave it open, and in the read-list
				} elsif ($resp[0] eq $SOCK_FILE) {
					# read from one or more files, and send them through the socket
					xlog("debug", "Got a file request [@resp]\n") if $conf{trace};
					*$sock{HASH}->{file} = [splice(@resp, 1)];
					$write_set->add($sock);
				} else {
					xlog("debug", "Packing $sock after resp\n") if $conf{trace};
					*$sock{HASH}->{resp} = packcmd(@resp);
					$write_set->add($sock);
				}
			} else {
				# append to growing message
				if ($bytes_read == 0) {
					xlog("debug", "Closing $sock after BR=0\n") if $conf{trace};
					close_sock($sock);
				} else {
					*$sock{HASH}->{buf} .= $buf;
				}
			}
		}
	}

    	foreach my $sock ($write_set->can_write(0)) {
		if (!*$sock{HASH}->{resp} && *$sock{HASH}->{file}) {
			if (*$sock{HASH}->{io}) {
				*$sock{HASH}->{resp} = '';
				*$sock{HASH}->{resp_offset} = 0;
				if (!sysread(*$sock{HASH}->{io}, *$sock{HASH}->{resp}, 4096)) {
					close *$sock{HASH}->{io};
					delete *$sock{HASH}->{io};
				}
			}
			if (!*$sock{HASH}->{io}) {
				my $file = splice(@{*$sock{HASH}->{file}}, 0, 1);
				while (-d $file) {
					# requests for directories are, for now, summarily ignored
					$file = splice(@{*$sock{HASH}->{file}}, 0, 1);
				}
				if ($file) {
					xlog("debug", "Sending $file over $sock\n") if $conf{trace};
					my $head = "name:$file\nlen:" . (-s $file) . "\n";
					my $io = new IO::File;
					if (!open ($io, $file)) {
						$head .= "error:'$file' : $!\n";
					} else {
						*$sock{HASH}->{io} = $io;
					}
					*$sock{HASH}->{resp} = $head . "\n";
					*$sock{HASH}->{resp_offset} = 0; 
					sysread(*$sock{HASH}->{io}, *$sock{HASH}->{resp}, 4096, length(*$sock{HASH}->{resp})); 
				} else {
					delete *$sock{HASH}->{file};
				}
			}
		}

    		if (*$sock{HASH}->{close}) {
			xlog("debug", "Closing $sock after close flag\n") if $conf{trace};
			close_sock($sock);
		} elsif (length(*$sock{HASH}->{resp})) {
			xlog("debug", "Writing $sock " . substr(*$sock{HASH}->{resp},0,1000)) if $conf{trace};

			my $nb = syswrite($sock, *$sock{HASH}->{resp}, length(*$sock{HASH}->{resp}), *$sock{HASH}->{resp_offset});
			if (!$nb) {
				xlog("error", "Socket failed to write", $sock);
				close_sock($sock);
			} else {
				*$sock{HASH}->{resp_offset}+= $nb;
				if (*$sock{HASH}->{resp_offset} >= length(*$sock{HASH}->{resp})) {
					delete *$sock{HASH}->{resp};
					if (!*$sock{HASH}->{file}) {
						*$sock{HASH}->{close} = 1;
					}
				}
			}		
		} else {
			xlog("debug", "Closing $sock after nothing to do\n") if $conf{trace};
			close_sock($sock);
		}
	}
}

sub close_sock {
	my ($sock) = @_;
	$read_set->remove($sock);
	$write_set->remove($sock);
	close($sock);
}

sub process_message {
	my ($data, $sock) = @_;
	xlog("note", "Received command $data from " . $sock->peerhost() . "\n") if $conf{trace};
	my $arr = $safe->reval($data);
	return unless ref($arr) eq 'ARRAY';
	my ($cmd, @args) = @$arr;

	if ($cmd eq 'xcmd') {
		# these commands 'query or interfere' with normal running of the server 
		# they are initiated by a user	
		my $ip = $sock->peerhost();

		if ($args[0] eq 'relo') {
			# reread config... maybe rebind stuff too
			xlog("note", "Reload from remote command ($ip)");
			init();
			return 'ok';
		} elsif ($args[0] eq 'term') {
			xlog("note", "Shutdown from remote command ($ip)");
			$quit = 1;
			return 'ok';
		} elsif ($args[0] eq 'rest') {
			xlog("note", "Restarting from remote command ($ip)");
			close_sock($listener);
			if (!fork) {
				exec($0, '-d');
			}
			$quit = 1;
			return "ok";
		} elsif ($args[0] eq 'stat') {
			shift @args;
			return shownodes(@args);
		} elsif ($args[0] eq 'hist') {
			splice(@args, 1);
			return showhist(@args);
		} elsif ($args[0] eq 'conf') {
			return showconf();
		} elsif ($args[0] eq 'jobs') {
			shift @args;
			return showjobs(@args);
		} elsif ($args[0] eq 'file') {
			shift @args;
			xlog("note", "Sending file [@args] to remote via xcmd ($ip)");
			return ($SOCK_FILE, @args);
		} else {
			return "Error: unknown xcmd '$args[0]'";	
		}
	} elsif ($cmd eq 'trace') {
		# turn tracing on... should be 'session' oriented but too lazy for now
		$conf{trace} = 0+$args[0];
	} elsif ($cmd eq 'node') {
		# this is the 'node ping'
		if (ref($args[0]) eq 'HASH') {		# bit of validation
			my $ip = $sock->peerhost();	# store info in a file, for fun
			my $file = "$conf{spool}/nodes/$ip.reg";
			open(F, ">$file") || return("Error: can't create $file : $!");
			print F $data;
			close F;
			# also stick in memory
			my $node = $args[0];
			if (!$nodes{$ip}) {
				xlog("note", "Registering node $ip:$node->{port} $node->{hostname}");
			}
			$nodes{$ip} = $args[0];
			$nodes{$ip}->{ip} = $ip;
		} else {
			return "Error: invalid node registration info";	
		}
        } elsif ($cmd eq 'jedit') {
		my ($jid, $key, $val) = @args;
		if (!$key || !defined($val)) {
                	xlog("error", "Invalid edit request ($jid,$key,$val)");
                	return "Invalid edit request ($jid,$key,$val)\n";
		} elsif (! -e "$conf{spool}/jobs/$jid") {
                        if (! -e "$conf{spool}/jobs/$jid.ip") {
                                xlog("error", "Job $jid not found.");
                                return "Job $jid not found.";
                        } else {
                                my $ip = slurp("$conf{spool}/jobs/$jid.ip");
                                # tell client to send an 'xedit' to the running node
                                return "Forward $ip:" . $nodes{ip}->{port};
                        }
                } else {
			my $ref = $safe->reval(slurp("$conf{spool}/jobs/$jid"));
			$ref->[0]->{$key} = $val;
			burp("$conf{spool}/jobs/$jid.jedit");
			rename("$conf{spool}/jobs/$jid.jedit", "$conf{spool}/jobs/$jid");
                        return "Job $jid edited\n";
                }
        } elsif ($cmd eq 'jkill') {
		# this is the 'job kill command'
		my ($jid) = @args;
		if (! -e "$conf{spool}/jobs/$jid") {
			if (! -e "$conf{spool}/jobs/$jid.ip") {
				xlog("error", "Job $jid not running, but kill requested");
				return "Job $jid not running.";
			} else {
				my $ip = slurp("$conf{spool}/jobs/$jid.ip");
				# send xabort to correct node
				return "Forward $ip:" . $nodes{ip}->{port};
			}
		} else {
			unlink "$conf{spool}/jobs/$jid";
			return "Job $jid aborted\n";
		}
	} elsif ($cmd eq 'jstat') {
		# sent by the execution node to say what the status of a job is
		my %opts = @args;
		if ($opts{id}) {
			my $ip = $sock->peerhost();	# should match the ip from jmine (see above how dumb this is)
			if (! -e "$conf{spool}/jobs/$opts{id}:$ip.run") {
				xlog("error", "Got a report for a job $opts{id} from $ip");
			}
			if ($opts{jrun}) {
				# just a ping
				xlog("debug", "I'm still alive ...$opts{id} from $ip") if $opts{trace} || $conf{trace};
				touch("$conf{spool}/jobs/$opts{id}:$ip.run");
			} elsif (defined $opts{status}) {
				# job is done
				open(ST, ">" . jhistpath($opts{id}));
				my $jhist = slurp("$conf{spool}/jobs/$opts{id}:$ip.run");
				substr($jhist,0,2) = "[{host=>'" . $ip  . "', status=>" . (0+$opts{status}) . ",";
				print ST $jhist;
				close ST;
				unlink("$conf{spool}/jobs/$opts{id}:$ip.run");
				unlink("$conf{spool}/jobs/$opts{id}.ip");
			} else {
				xlog("error", "Got a report for a job $opts{id} with no status info");
			}
			# return ack even if not exists
			return ('dack', %opts);	
		}
        } elsif ($cmd eq 'dack') {
		# ackknowledge receipt of status signal, so you don't have to do it again
                my %opts = @args;
                if ($opts{pid}) {
			if (!$opts{jrun}) {
				# stop tracking this pid
				my $info = gunpack(slurp("$conf{spool}/pids/$opts{pid}"));
				unlink("$conf{spool}/pids/$opts{pid}");
				if (!$info->{wait}) {
					# nobody asked for the output, so don't keep it
					unlink("$conf{spool}/jpids/$info{id}");
					unlink("$conf{spool}/pids/$opts{pid}.stat");
					unlink("$conf{spool}/stdio/$opts{pid}.err");
					unlink("$conf{spool}/stdio/$opts{pid}.out");
				}
			}
		}
	} elsif ($cmd eq 'exec') {
		my ($opts, @cmd) = @args;

		my ($uid, $gid, $err);
		if ($opts->{user}) {
			(undef, undef, $uid, $gid) = getpwnam($opts->{user});
		}
		if (defined($uid) && !$conf{run_asroot} && !$uid) {
			$err="Won't run as root";
		}
		if (!defined($uid)) {
			$err="User $opts->{user} is unknown on this machine, not executing";
		}

		# expecting someone to come pick up output?
		$io_wait{$opts->{id}}->{type} = 'stat' if $opts->{wait};	# status wait
		$io_wait{$opts->{id}}->{type} = 'io' if $opts->{io};		# io wait

		my $pid;

		if ($conf{wrap}) {
			@cmd = ($conf{wrap}, @cmd);
		}

		if (!$err && !($pid=fork)) {
			if (! defined $pid) {
				$err = "Can't fork";
			} else {
				# restore signal to default ... regular kill
				$SIG{INT} = undef;
				$SIG{TERM} = undef;

				# kill me with a negative number, all kids die too
				# kill my parent.... i stay alive, and my IO is still ready to go
				POSIX::setsid();
	
				my $noexec = "$conf{spool}/pids/$$.noexec";

				if ($opts->{io}) {
					open STDERR, ">$conf{spool}/stdio/$$.err";
					open STDOUT, ">$conf{spool}/stdio/$$.out";
				} else {
					# save disk and time, i never want i/o
					open STDERR, ">/dev/null";
					open STDOUT, ">/dev/null";
				}
				
				# copy in the umask & the environment
				umask $opts->{umask};
				for (keys(%{$opts->{env}})) {
					$ENV{$_}=$opts->{env}->{$_};
				}
			
				for (keys(%{$opts})) {
					next if ref($opts->{$_});
					$ENV{"_GRUN_OPT_$_"} = $opts->{$_};
				}
				$ENV{"_GRUN"} = 1;
				my $err;

				xlog("debug", "Setting uid to $uid, gid to $gid.\n") if ($conf{trace} || $opts->{trace});

				eval {	
					if ($gid) {
						$) = $gid;
						$( = $gid;
					}
					$> = $uid;
					$< = $uid;
					if ($opts->{cwd}) {
						if (!chdir($opts->{cwd})) {
							$err = "Can't cd to $opts->{cwd} : $!";
						}
					}
				};

				$err = "Error setting uid to $uid: $@\n" if !$err && $@;
				if (!$err) {
					exec(@cmd);
					printf STDERR "Can't cd to $opts->{cwd} : $!\n";	
					exit 101;
				} else {
					printf STDERR "$err\n";	
					exit -1;
				}
				# special exit code means couldn't run the command
			}
		}

		if ($err) {
			# fake it
			$pid = $opts->{id};
			xlog("note", "Error $err with job $opts->{id}");
		}

		xlog("note", "Starting job $opts->{id}, pid $pid, '@cmd'") if !$err;

		my $file = "$conf{spool}/pids/$pid";

		if (!open(F, ">>$file"))  {
			xlog("error", "Can't create $file : $!");
		}
		print F "ip:" . $sock->peerhost() . "\n";
		print F "id:" . $opts->{id} . "\n";
		print F "port:" . $opts->{port} . "\n";
		print F "wait:" . $opts->{wait} . "\n";
		print F "io:" . $opts->{io} . "\n";
		print F "error:" . $err . "\n" if $err;
		close F;

		$file = "$conf{spool}/jpids/$opts->{id}";
		if (!open(F, ">>$file")) {
			xlog("error", "Can't create $file : $!");
		}
		print F $pid;
		close F;

		if ($err) {
			if (writestat($pid, -3, 0, $err)) {
				notifystat($pid);
			}
		}
	} elsif ($cmd eq 'xclean') {
		# cleanup, i got everything
		my ($jid) = @args;
		my $pid = slurp("$conf{spool}/jpids/$jid");
		if ($pid > 1) {
			unlink  "$conf{spool}/jpids/$jid", "$conf{spool}/stdio/$pid.out", "$conf{spool}/stdio/$pid.err", "$conf{spool}/pids/$pid.stat";
		} else {
			xlog("error", "Got a cleanup for $jid which doesn't exist");
		}
        } elsif ($cmd eq 'xabort') {
                # kill job
                my ($jid, $sig) = @args;
                my $pid = slurp("$conf{spool}/jpids/$jid");
		if ($pid > 1) {
			xlog("note", "Aborting jobs $jid ($pid) on request");
			$sig = 2 if !$sig;
			my $ok = kill $sig, -$pid;		# parent, and all kids
			$ok |= kill $sig, $pid;		# parent if, for some reason, that didn't work
			if ($ok) {
				return "Job $jid aborted"; 
			}
		} else {
			return "Job $jid not found"; 
		}
	} elsif ($cmd eq 'xio') {
		my ($jid) = @args;
		$io_wait{$jid}->{type} = 'io';
		$io_wait{$jid}->{sock} = $sock;
		$io_wait{$jid}->{time} = time();		# toss this entry if it gets old
#		print "IOWAIT: " . Dumper \%io_wait;
		return ($SOCK_WAIT);				# leave socket open for response
        } elsif ($cmd eq 'xstat') {
                my ($jid) = @args;
		my $pid = slurp("$conf{spool}/jpids/$jid");
		# xstat means you don't want i/o, just status... these shouldn't even exist
		unlink  "$conf{spool}/stdio/$pid.out", "$conf{spool}/stdio/$pid.err";
		$io_wait{$jid}->{type} = 'stat';
		$io_wait{$jid}->{sock} = $sock;
		$io_wait{$jid}->{time} = time();		# toss this entry if it gets old
		return ($SOCK_WAIT);				# leave socket open for response
	} elsif ($cmd eq 'run') {
		# user command, returns jid=>jobid [, error=>string]
		if (!$conf{services}->{queue}) {
			return (error=>"No queue service running on this host");	
		} else {
			# get rid of the 'run' at the front of the array
			return(error=>"Network data format error") 
				unless $data =~ s/^\['run',/[/;

			my ($opts) = @args;
			my $time = time();
			++$gjobid;

			# no half-written id's
			burp("$conf{spool}/nextid.tmp", $gjobid);
			rename "$conf{spool}/nextid.tmp", "$conf{spool}/nextid";

			# the job file
			my $jid = $gjobid;
			my $file = "$conf{spool}/jobs/$jid";

			# stick the host the job came from and the start time in there.
			my $ip = $sock->peerhost();
			substr($data,0,2) = "[{time=>" . $time . "," . "from=>'" . $ip . "',";

			open(F, ">$file") || return('', "Can't create $file : $!");
			print F $data;
			close F;

			# want i/o or status?
			if ($opts->{wait}) {
				$run_wait{$jid}->{sock} = $sock;
				$run_wait{$jid}->{type} = 'start';	# socket waits for execution start
				return ($SOCK_WAIT);			# leave socket open for response
			} else {
				return (jid=>$jid);			# nice and fast, no i/o
			}
		}	
	}
	return ();
}

sub jhistpath {
	my ($id) = @_;
	my $left = int($id/10000);
	my $right = $id;
	my $dir = "$conf{spool}/jhist/$left";
	mkdir($dir) if ! -d $dir;
	return "$dir/$right";
}

sub schedule {
	opendir(D,"$conf{spool}/jobs");

	return unless %nodes;

	if (time() > ($conf{lastschedtime} + $conf{sched_secs})) {
		$conf{lastschedtime} = time();
	} else {
		return;
	}

	# no attempt here to prioritize jobs, just match and go
	while(my $jid=readdir(D)) {
		my $jfil = "$conf{spool}/jobs/$jid";

		# these are annoying... see jmine
		if ($jfil =~ /\.ip$/) {
			next;
		}

		next unless -f $jfil;
		my $ref = $safe->reval(slurp($jfil));
		if (!(ref($ref) eq 'ARRAY')) {
			xlog("error", "Invalid job file format: $jfil\n");
			unlink $jfil;
		}

		if ($jfil =~ /\.run$/) {
			# check to see whether job has expired
			if ($conf{expire_secs} && (fmodtime($jfil) < (time()-$conf{expire_secs}))) {
				xlog("error", "TODO: Deal with job expiration of $jfil\n");
				# rename back to active job?
				# leave in queue as held (since it may have executed)
				# config policy?
				# coniig default?
			} 
			next;
		}

		my @dereg;
		my @n;
		my ($max_av, $max_n);

		# this should be config, min requirements
		$ref->[0]->{cpus} = 1 if $ref->[0]->{cpus} == 0;
		$ref->[0]->{memory} = 10000 if $ref->[0]->{memory} == 0;

		for my $n (values %nodes) {
			# jobs need enough memory, cpu availability and disk space... that's it
			if (!$n->{ip}) {
				xlog("error", "Node has no ip! " . Data::Dumper->new($n)->Indent(0)->Terse(1)->Dump());
			}
			if ($n->{ping} > (time()-$conf{ping_secs}*3)) {
				if ( ($n->{mem} >= $ref->[0]->{memory}) &&
				     ($n->{avail} >= $ref->[0]->{cpus}) && 
				     ($n->{disk} >= $ref->[0]->{disk}) 
				   ) {
					next if $ref->[0]->{hosts} && $ref->[0]->{hosts} !~ /$n->{hostname}/;

					my $match = 1;
					if ($conf{match}) {
						$match = evalctx($conf{match}, node=>$n, job=>$ref->[0]);	# eval perl expression
						if ($@) {
							$match = 1;						# permit all on error?
						}
					}
					next unless $match;

					if ($n->{load} < $conf{idle_load}) {
						# don't bother checking further, this node is bored
						$max_n = $n;
						last;
					} else {
						if ($n->{avail} > $max_av) {
							$max_n = $n;
							$max_av = $n->{avail};
						}
					}
				}
			} else {
				push @dereg, $n->{ip};
			}
		}
		for my $ip (@dereg) {
			xlog("note", "Deregister node '$ip', last ping was " . (time()-$nodes{$ip}->{ping}) . " seconds ago");
			delete $nodes{$ip};
		}
		if ($max_n) {
			# todo... change this
			my $jmine = "$jfil:" . $max_n->{ip} . ".run";
			touch($jfil);
			rename($jfil, $jmine);
			if ( -e $jmine ) {
				my $jptr = "$jfil" . ".ip";
				burp($jptr, $max_n->{ip});
				if (!noderun($max_n, $jid, $ref)) {
					# failed to execute job, put it back
					rename($jmine, $jfil);
					$max_n->{avail} = 0;
				} else {
					$max_n->{avail} -= $ref->[0]->{cpus} ? $ref->[0]->{cpus} : 1;
					$max_n->{memory} -= $ref->[0]->{memory} ? $ref->[0]->{memory} : 10000;
				}
			}
		} else {
			if ($conf{full_cmd}) {
				# TODO: fork exec to backup grid, and add to list of pids to track... as if you're an exec node
			}
			xlog("debug", "Can't find node for $jfil " . Dumper(%nodes) . "\n") if $conf{trace};
		}
	}

	# kickstart nodes, if needed
	kicknodes();

	return undef;
}

sub noderun {
	my ($n, $jid, $job) = @_;
	# send 'exec'
	$job->[0]->{port} = $conf{port};		# reply to me on this port
	$job->[0]->{id} = $jid;
	if ($run_wait{$jid}) {
		# info needed for status/stdio collection
		if ($run_wait{$jid}->{type} eq 'start') {
			my $pid = $run_wait{$jid}->{pid};
			my $sock = $run_wait{$jid}->{sock};
			sockresp($run_wait{$jid}->{sock}, jid=>$jid, ip=>$n->{ip}, port=>$n->{port});
		}
	}
	return sendcmd($n->{ip}, $n->{port}, 'exec', @$job);
}

sub sockresp {
	my $sock = shift @_;
	*$sock{HASH}->{resp} = packcmd(@_);
	$write_set->add($sock);
}

# called at start, and kill -HUP
sub init {
	readconf();
	if ($daemon) {
		mkdir $conf{spool};
		mkdir "$conf{spool}/jobs";
		mkdir "$conf{spool}/stdio";
		mkdir "$conf{spool}/jhist";
		mkdir "$conf{spool}/nodes";
		mkdir "$conf{spool}/pids";
		mkdir "$conf{spool}/jpids";
		# reregister on reread
		delete $conf{node};
	}
	$conf{hostip} = host2ip($conf{hostname});
}

sub getmem {
	my ($cache, $free);
	open F, "/proc/meminfo";
	while (<F>) {
		$free = $1 if /MemFree:\s*(\d+)/i;
		$cache = $1 if /Cached:\s*(\d+)/i;
		last if $cache & $free;
	}
	close F;
	return $cache + $free;
}

sub getcpus {
	my $cores;
	open F, "/proc/cpuinfo";
	my %cores;
	my $p;
        while (<F>) {
                $p = $1 if /physical id\s*:\s*(\d+)/i;
                $cores{"$p$1"} = 1 if /core id\s*:\s*(\d+)/i;
                $cores += 1 if /processor\s*:\s*(\d+)/i;
        }
	close F;
	$cores = scalar keys %cores if %cores;
	return $cores;
}

sub slurp
{
    my $dat;
    my $in = new IO::File;
    return undef unless open($in, $_[0]);
    local $/ = undef;
    $dat = $in->getline;
    $in->close;
    return $dat;
}

sub srvexec {
	if ($conf{services}->{exec} && (!$conf{node} || (time() > ($conf{node}->{ping}+$conf{ping_secs}-1)))) {
		# ping master with stats
		$conf{node}->{arch} = `arch`; chomp $conf{node}->{arch};
		$conf{node}->{mem} = getmem();					# free mem
		$conf{node}->{load} = slurp("/proc/loadavg");			# load
		$conf{node}->{cpus} = $conf{cpus} ? $conf{cpus} : getcpus();	# num cores
		$conf{node}->{avail} = $conf{node}->{cpus} - $conf{node}->{load};	
		$conf{node}->{ping} = time();
		$conf{node}->{port} = $conf{port};
		$conf{node}->{hostname} = $conf{hostname};
		$conf{node}->{kernel} = `uname -rv`; chomp $conf{node}->{kernel};
		$conf{node}->{arch} = `uname -h`; chomp $conf{node}->{arch};
		
		$conf{registered} = 1;
		if (!xsend("node", $conf{node})) {
			$conf{registered} = 0;
		}
	}

	while ((my $kid = waitpid(-1, WNOHANG)) > 0) {
		my $status = $?;
#		print "waitpid worked status is $?\n";
		if (writestat($kid, $status)) {
			$conf{node}->{ping}-=5;					# hurry up to let scheduler know I'm free
			notifystat($kid);
		} else {
			xlog("error", "Premature status sent on pid $kid");
		}
	};

	# anyone who'se waiting, and has a pid and a socket... deal with it
	for my $jid (keys(%io_wait)) {
		my $pid = $io_wait{$jid}->{pid};
		if ($pid) {
			if ($io_wait{$jid}->{sock}) {
				my $sock = $io_wait{$jid}->{sock};
				# assert $pid = $io_wait{$jid}->{pid}
				if ($io_wait{$jid}->{type} eq 'io') {
					# need all IO
#					print "SENDING FILES : " . Dumper $io_wait{$jid};
					*$sock{HASH}->{file} = ["$conf{spool}/pids/$pid.stat", "$conf{spool}/stdio/$pid.out", "$conf{spool}/stdio/$pid.err"];
					$write_set->add($sock);
				} elsif ($io_wait{$jid}->{type} eq 'stat') {
					# only want a status code
					my $stat = funpack("$conf{spool}/pids/$pid.stat");
					sockresp($io_wait{$jid}->{sock}, $stat->{status});
					unlink "$conf{spool}/pids/$pid.stat";
					unlink "$conf{spool}/jpids/$jid";
				}
				delete $io_wait{$jid};
			} elsif (time() > ($io_wait{$jid}->{time}+$conf{io_keep})) {
				xlog("error", "Orphaned I/O getting deleted for job $jid after $conf{io_keep} secs\n");
				unlink "$conf{spool}/pids/$pid", "$conf{spool}/jpids/$jid", 
					"$conf{spool}/pids/$pid.stat", "$conf{spool}/pids/$pid.out", "$conf{spool}/pids/$pid.err";
				delete $io_wait{$jid};
			}
		}
	}


	if (time() > ($conf{lastpidtime}+$conf{ping_secs})) {
		opendir(D,"$conf{spool}/pids");
		while(my $kid = readdir(D)) {
			# finished, notify submitter

			if ($kid =~ /^(\d+)\.noexec$/) {
				if (writestat($1, -2, 0, slurp($kid))) {
					unlink "$conf{spool}/pids/$kid";
				}
				next;
			}

			if ($kid =~ /\.stat$/) {
				if (fmodtime("$conf{spool}/pids/$kid") < (time()-$conf{ping_secs})) {
					if (notifystat($kid)) {
						touch("$conf{spool}/pids/$kid");
					}
				}
				next;
			}
			# running, check status
			if ($kid =~ /^\d+$/ ) {
				my $ret = waitpid($kid, WNOHANG);
				my $status = $?;
				my $alive = kill(0, $kid);
				#print "RET $ret STAT $status ALIVE $alive\n";
				if (writestat($kid, $status, $alive)) {
					notifystat($kid);
				}
			}
		}
		closedir D;

		# remove associated
		opendir(D,"$conf{spool}/stdio");
		while(my $kid = readdir(D)) {
			if (! -e "$conf{spool}/pids/$kid.stat") {
				unlink "$conf{spool}/stdio/$kid";
			}
		}
		closedir(D);

		$conf{lastpidtime} = time();
	}
}

sub touch {
	open(T,">>$_[0]");
	close T;
}

sub fmodtime {
	return (stat($_[0]))[9];
}

sub notifystat {
	my ($kid) = @_;
	$kid =~ s/.stat$//;
	my $info = funpack("$conf{spool}/pids/$kid");

	if (!$info->{ip}) {
		unlink "$conf{spool}/pids/$kid.stat";
		xlog("error", "Orphaned job status file $kid");
		return;
	}
	
	my $jid = $info->{id};

	# tell scheduler the status

	# this breaks multi-scheduling... but that isn't supported yet, and tunnels are acting odd
	$info->{ip} = $conf{master};
	$info->{port} = $conf{master_port};

	xlog("debug", "Notifying status " . Dumper($info) . ".\n") if ($conf{trace} || $info->{trace});

	funpack("$conf{spool}/pids/$kid.stat", $info);
	my $sock = _sendcmd($info->{ip}, $info->{port}, 'jstat', id=>$info->{id}, status=>$info->{status}, pid=>$kid, jrun=>$info->{jrun}, error=>$info->{error});
	$read_set->add($sock) if $sock;

#	print STDERR "HERE I AM NOTIFYING: " . Dumper($info);
	if (!$info->{jrun}) {
		# ok, i'm not running
		# release stdio/stat
#		print STDERR "HERE I AM RELEASING STUFF $kid " . Dumper($info);
		if ($io_wait{$jid}) {
			$io_wait{$jid}->{pid} = $kid;
			$io_wait{$jid}->{time} = time();		# how long you have to pickup i/o
		}
	}
}

sub writestat {
	my ($kid, $stat, $jrun, $err) = @_;
	if ( -e "$conf{spool}/pids/$kid" ) {
		if (!$err) {
			if ( -e "$conf{spool}/pids/$kid.noexec" ) {
				$err=slurp("$conf{spool}/pids/$kid.noexec");
				unlink("$conf{spool}/pids/$kid.noexec");
			}
		}
		open(ST, ">$conf{spool}/pids/$kid.stat") || return 0;
		print(ST "status:$stat\n");
		print(ST "jrun:1\n") if $jrun;
		print(ST "error:$err\n") if $err;
		return close ST;
	}
	return 1;
}

sub gpack {
	my $msg;
	for (my $i=0;$i<@_;$i+=2) {
		$_[$i+1] =~ s/\n/ /g;
		$msg .= $_[$i] . ":" . $_[$i+1] . "\n";
	}
        return $msg;
}

sub funpack {
        my ($fil, $dat) = @_;
	return gunpack(slurp($fil), $dat);
}

sub gunpack {
	my ($msg, $dat) = @_;
	$dat = {} if !$dat;
	for (split(/\n/, $msg)) {
                my ($k, $v) = m/^\s*([^:]+)?\s*:\s*(.*?)\s*$/;
                $k = lc($k);
		$dat->{$k}=$v;
	}
	return $dat;
}

sub readconf {
        %conf = %def;

	_readconf("$conf{config}");

        # defines happen at the end so defaults can get unpacked
        for (keys %conf) {
		next if ref $conf{$_};
		if ($_ eq 'match') {
			# match rules are evaluated during matching, but reval now just to test
			my $test = $conf{$_};
			# see http://www.perlmonks.org/?node_id=685699 for why this is OK
			$test =~ s/`[^`]+`/1/g;
			$test =~ s/system\([^\)]\)/1/g;
			$safe->reval($test);
			if ($@) {
				xlog("error", "Error testing match rule : $@");
			}
			$@='';
		} elsif ( ! ($conf{$_} =~ s/^\{(.*)\}$/eval($1)/gei) ) {
                	$conf{$_} =~ s/\$([\w-]+)/$conf{lc($1)}?$conf{lc($1)}:$1/gei;
		}
        }

        #reorganize stuff

	my $v;
	$v = $conf{services};
	$conf{services} = {};
	for (split(/[\s,]+/,$v)) {
		$conf{services}->{$_} = 1;
	}

	$conf{env} = [split(/[\s,]+/,$conf{env})] unless ref($conf{env}) eq 'ARRAY';

	$conf{master_port} = $1 if $conf{master} =~ s/:(\d+)$//;
	$conf{master_port} = $conf{port} if !$conf{master_port};

	$conf{port} = $1 if $conf{bind} =~ s/:(\d+)$//;
}

sub _readconf {
	my ($f) = @_;
	%conf = %def;
	if (!open(CONF, $f)) {
		xlog("error", "Can't open '$f'");
		return;
	}
	while(<CONF>) {
		next if /^\s*#/;
		my ($k, $v) = m/^\s*([^:]+)?\s*:\s*(.*?)\s*$/;
		$k = lc($k);
		if ($k eq 'include') {
			_readconf($v);
		} else {
			$conf{$k} = $v;
		}
	}
}

sub fail {
        xlog("error", @_);
        croak @_;
}

sub xlog {
        my $m = join("\t", @_);
        $m =~ s/\n/ /g;
        my $line = scalar(localtime) . "\t" . $m . "\n";
        my $log = $conf{"log_file"};
        if ($log && ! ($log eq '-')) {
                open LOG, ">>" . $log;
                print LOG $line;
                close LOG;
        } else {
                print $line;
        }
        return $line;
}

sub waitio {
	my $opts = shift @_ if ref $_[0];
        my $sock = _sendcmd(@_);
        if (!$sock) {
                xlog("error","Can't send command ", packcmd(@_));
                return undef;
        }
        my ($dat, $stat, $got) = ('', '', 0);
	my $err;
        while ($got<3) {
		my $buf = '';
		my %head;
		my $break = 0;
		do {
			$buf .= $dat;
			while ($buf =~ s/^([^\n]+?) *: *([^\n]*?) *\n//) {
				$head{$1}=$2;
			}
			if ($buf =~ s/^\n//) {
				$dat = $buf;
				$break = 1;
			}
		} while (!$break && $sock->sysread($dat, 4096));

		$err = $head{error} if $head{error};

#		print Dumper(\%head);
#		print "DAT IS: $dat\n";

		last if (!$head{name});

		my $statstr;  
		my $fh;

		if ($opts->{inplace} && (!$head{error})) {
			# inplace file retrieval
			my $dir = $head{name};
			$dir =~ s/[^\/]+$//;
			system("mkdir", "-p", $dir) if ! -e $dir;
			open($fh = new IO::File, '>', $head{name}); 
		} else {
			# stderr/out/stat 
			$fh = $head{name}=~/\.err$/ 
				? *STDERR
				: *STDOUT;

			$statstr = 1 if $head{name}=~/\.stat$/;
		}

		my $left = $head{len};

		++$got;
		do {
#			print STDERR "left: $left dat:" . length($dat) . "\n"; 
			if ($left>0) {
				if ($statstr) {
					$stat .= substr($dat,0,$left);
				} else {
					print $fh substr($dat,0,$left);
				}
				$left -= length($dat);
				substr($dat,0,$left) = '';
			}
#			print STDERR "left: $left dat:" . length($dat) . "\n"; 
		} while ($left>0 && $sock->sysread($dat, 4096));
		if ($opts->{inplace}) {
			close $fh;
			$got = 3;
		}
	}
	if ($stat) {
		$stat = gunpack($stat);
		return ($stat->{status}, $stat->{error});
	}
	return (!($err eq ''), $err);
}

sub waitmsg {
	my $sock = _sendcmd(@_);

	if (!$sock) {
                xlog("error", "Can't send command ", packcmd(@_));
		return ();
	}
	my ($buf, $dat);
	while ($sock->read($dat, 4096)) {
		$buf .= $dat;
	}
	if (substr($buf,-2,2) eq $EOT) {
		substr($buf,-2,2) = '';
		return unpackcmd($buf);
	}
	$@="Socket protocol error, no EOT";
	return ();
}

sub xsend {
	my $sock = _sendcmd($conf{master}, $conf{master_port}, @_);
	if ($sock) {
		close $sock;
		return 1;
	}
	return 0;
}

sub sendcmd {
	my $sock = _sendcmd(@_);
	return $sock ? close($sock) : undef;  
}

sub packcmd {
	return Data::Dumper->new([\@_])->Indent(0)->Terse(1)->Dump().$EOT;
}

sub unpackcmd {
	my $ref = $safe->reval($_[0]);
	if (ref($ref) eq 'ARRAY') {
		return @$ref;
	}
}

sub _sendcmd {
	my ($host, $port, @cmd) = @_;
	my $xcmd = packcmd(@cmd);
        my $sock = IO::Socket::INET->new(Proto=>"tcp",PeerPort=>$port,PeerAddr=>$host, Timeout=>5);
        if (!$sock) {
                xlog("error",$@="Can't connect to $host:$port", Carp::longmess());
		return undef;
        }
        if ($sock->send($xcmd)) {
		return $sock;
	}
}

sub burp
{
        my ($f, $dat) = @_;
        my $h = new IO::File;
        open ($h, ">$f");
        print $h $dat;
        close $h;
}

sub usage {
	my $u;
	$u .= <<'EOF';
Usage: grun <exec-options> command...
   or: grun -d [<local-daemon-options>]
   or: grun -k <jobid>
   or: grun -e <jobid> key val
   or: grun -q [<query-options>] <query-command>

Lightweight job queueing system

For more help, run grun -?, grun -d -?, grun -C -? or grun -q -?.
EOF

	$u .= <<'EOF' unless $daemon || $qinfo;

Execution Options:
    -f|ile FILE     Read FILE for job options
    -t|race         Trace mode (verbose logging)

    -m|em INT       memory minimum in MB
    -c|pu CPUS	    minimum number of cpus 
    -host N1,N2     specify certain hosts

    -noio           disable io-processing, but wait for completion
    -nowait         no io and don't wait, just start the command
    -e|rr FILE      write stderr directly to FILE, no spool
    -o|ut FILE      write stdout directly to FILE, no spool

If the command contains shell metacharacters, it's prefixed with "bash -c".
EOF

	$u .= <<'EOF' if $qinfo;

Query Options:
    -a|ll           Query all nodes
    -n|odes         ($master) List of nodes to query

Query Commands:
    [-]status       List nodes (q)
    [-]jobs         List jobs (q)
    [-]history      List prior jobs (q)
    [-]conf         Dump config from memory (q,e)
EOF

	$u .= <<'EOF' if $daemon;

Daemon Options:
    -h|osts         (local) One or more hosts
    -r|eload        Reload config
    -k|ill          Kill running server
    -R|ESTART       Kill and restart a running server

Without an option, -d just starts the daemon on the local machine.
EOF

	$u .= <<'EOF';

Common Options:
    -C FILE         (/etc/grun.conf) Config file location
    -t|race         Turn on debugging in the log file
    -v|ersion       Print version and exit
    -?              Show this help page
EOF

	$u .= <<'EOF' if defined $config;

Configuration File:

All config variables written as {value} are interpreted as perl code, and get evaluated at startup.

The "include" varialbe actually just includes the file specified, as if it were part of the original file.

All non-code configuration variables can include '$varname', which gets expanded to the value of another config var.

Be careful with match code.  It it's slow, it will kill the performance of your main node.

Common variables:

    master          (localhost) Hostname[:port] of master node
    spool           (/var/spool/grun) Location for queue & io temp storage
    log_file	    Location of the log
    services        Must be 'queue' and/or 'exec'
    port            Port to listen on (5184)
    bind[:port]     Address to bind to (0.0.0.0)
    trace           Turn tracing on for the whole server

Queue config vars:

    env             (PATH) List of environment varialbes to copy to the processes.  An asterisk (*) means 'ALL'
    expire_secs     (0) If set, jobs that aren't pinged in time get (failed or retried)
    expire_action   (retry) Can be 'retry', 'fail'
    idle_load	    (.3) If load is less than this amount, then considered idle
    io_keep	    (3600) Time to keep unretrieved stdio files (0=forever)
    log_file        Where to send "xlog" output
    pid_file	    (/var/run/grun.pid)
    ping_secs       (30) Nodes ping the master this often.
    ping_expire     (2*$ping_secs) Drop a node if it doesn't ping in time

Execution node config vars:

    match           Perl code that must eval to TRUE for a node match
    full_match      (1) If jobs queue is full, this is evaluated
    full_exec       If full match returns true, then this command is run
    wrap            Job command wrapper
    
EOF
   return $u;
}

sub showconf {
	return Data::Dumper->new([\%conf])->Indent(1)->Terse(1)->Dump().$EOT;
}

sub showhist {
	my %opt=@_;

        my $r;

	my $mx = -1;
        opendir(D,"$conf{spool}/jhist");
	while(defined ($_=readdir(D))) {
		if ($_ > $mx) {
			$mx = $_;
		}
	}
	closedir(D);

        opendir(D,"$conf{spool}/jhist/$mx");
	my @D = sort {$a-$b} readdir(D);
	closedir(D);

	my $count = $opt{count}; 
	$count = 50 if !$count;

	splice @D, 0, @D-$count;
	
        for my $jid (@D) {
                my $f = "$conf{spool}/jhist/$mx/$jid";
                next unless -f $f;
                my @job=unpackcmd(slurp($f));
                my ($job, @cmd) = @job;
                if (ref($job)) {
                        my %job=%{$job};
			$job{status} = 'OK' if $job{status} eq '0';
			my $cmd = join(' ', @cmd);
			$cmd =~ s/\n\s+/\n/g;
			$cmd =~ s/^\s+//;
			$cmd =~ s/\s+$//;
			$cmd =~ s/\n/;/g;
			if ($nodes{$job{host}}->{hostname}) {
				$job{host}=$nodes{$job{host}}->{hostname} 
			} elsif (-e (my $n="$conf{spool}/nodes/$job{host}.reg")) {
				my @node=unpackcmd(slurp($n));
				$job{host}=$node[1]->{hostname};
			}
                        $r .= sprintf "%s\t%s\t%s\t%s\t%s\t%s\n",$jid,$job{user},$job{host},$job{status},$job{cwd},$cmd;
                }
        }
        return $r;
}

# grun -q status
sub shownodes {
        my $r;
        $r .= sprintf "%-15s %9s %5s\n", 'Hostname','Memory', 'Cpu';
	my @nodes = getnodes();
        for my $node (sort {$a->{hostname} cmp $b->{hostname}} @nodes) {
                if ($node->{ping} > time() - ($conf{ping_secs} * 2) ) {
                        $node->{hostname} = substr($node->{hostname},0,15);
                        chomp($node->{hostname});
                        $r .= sprintf "%-15s %8dm %5.1f\n", $node->{hostname}, $node->{mem}/1000, $node->{avail};
                }
        }
        return $r;
}

# grun -q jobs
sub showjobs {
	my %opt;
	
	{
		local @ARGV = @_;
		GetOptions(\%opt, "dump", "user=s");
		@_=@ARGV;
	}

	if (@_ == 1) {
		my $user = shift @_;	
		$opt{user}=$user if !($user eq '');
	}

	xlog("debug", "Show job for user: $opt{user}\n");

        my $r;
#        $r .= sprintf "%s\t%s\t%s\t%s\t%s\n", 'JobID','User','Host','Cwd','Command';
        opendir(D,"$conf{spool}/jobs");
        while(my $jid=readdir(D)) {
                my $f = "$conf{spool}/jobs/$jid";
                next unless -f $f;
                my @job=unpackcmd(slurp($f));
                my ($job, @cmd) = @job;
		if (ref($job)) {
			my %job=%{$job};
			next if $opt{user} && ! ($opt{user} eq $job{user});
			my $stat = '(I)';
			if ($jid =~ s/:([.\d]+?)\.run$//) {
				my $ip = $1;
				my @node = unpackcmd(slurp("$conf{spool}/nodes/$ip.reg"));
				if (ref($node[1])) {
					$stat = $node[1]->{hostname}; chomp $stat;
				}
			}
			# trim for display
			for (@cmd) {
				s/^\s+//g;
				s/\n\s*/;/g;
			}
			if ($opt{dump}) {
				$r .= packdump($job) . "\n";
			} else {
				$r .= sprintf "%s\t%s\t%s\t%s\t%s\n", $jid,$job{user},$stat,$job{cwd},join(' ', @cmd);
			}
		}
        }
        closedir(D);
        return $r;
}

sub bestunique {
	my ($c, @c)  = @_;
	my $b;
	for (@c) {
		if ($_ =~ /^$c/) {
			return undef if ($b);
			$b = $_;
		}
	}
	return $b;
}

# returns an array of [host,port], given a list of host[:port] names
sub expandnodes {
	my @r;
	my @n;
	for (split(/[\s,]/, join ' ', @_)) {
		my ($h, $p) =  m/^(.*)(:\d+)?$/;
		$p = $conf{port} if !$p;
		if ($h =~ s/\*/\.\*/g) {
			if (!@n) {
				@n=getnodes();	
			}
			for (@n) {
				push @r, [$_->{hostname}, $p] if $_->{hostname} =~ /$h/;
			}
		} else {
			push @r, [$h, $p];
		}
	}
	return @r;
}

sub evalctx {
	my ($expr, @ctx) = @_;
	my $msafe = new Safe;
	$msafe->permit(qw(:subprocess));        # allow backticks
	for(my $i = 0; $i < @ctx; $i+=2) {
		my ($name, $var) = ($ctx[$i], $ctx[$i+1]);
		# references to hashes/arrays become dereferenced hashes/arrays
		if (ref($var) eq 'HASH') {
			%{$msafe->varglob($name)}=%{$var};
		} elsif (ref($var) eq 'ARRAY') {
			@{$msafe->varglob($name)}=@{$var};
		} else {
			${$msafe->varglob($name)}=$var;
		}
	}
	$msafe->share(qw(%conf %ENV));
	if ($conf{trace}) {
		xlog("debug", "Evaluating {$expr}\n");
	}
	my ($res, @res);
	if (wantarray) {
		@res = $msafe->reval($expr);
	} else {
		$res = $msafe->reval($expr);
	}
	my $save = $@;
	if ($@) {
		xlog("error", "Error evaluating {$expr} : $@\n");
		return undef;
	}
	$@=$save;
	if (wantarray) {
		return @res;
	} else {
		return $res;
	}
}

sub kicknodes {
        my @nodes = getnodes(cached=>1);
	return if !$conf{kickstart};
        return if (time() < ($conf{lastkicktime} + $conf{ping_secs} * 4));
	$conf{lastkicktime} = time();
	for my $node (@nodes) {
		# sometime in the last 24 hours?
		if ($node->{ping} > (time() - ($conf{remove_secs}))) {
			# but not in the last couple minutes
			if ($node->{ping} < (time() - ($conf{ping_secs} * 4)) ) {
				# kick it
				xlog("note", "Kicking node $node->{hostname}\n");
				if (fork) {
					my $cmd = $conf{kickstart};
					if ($cmd =~ /^\{(.*)\}$/) {
						$cmd = evalctx($1, node=>$node);
					}
					if ($cmd && $cmd !~ /\$/) {
						exec("$cmd");	
					}
				}
			}
		}
	}
}

sub getnodes {
	my (%opt) = @_;
	my @r;
	if (!$opt{cached} && %nodes) {
		# return memcached values
		return values %nodes;
	}
	# read all from disk, including old ones
        opendir(D,"$conf{spool}/nodes");
        while($_=readdir(D)) {
                $_ = "$conf{spool}/nodes/$_";
                next unless -f $_;
                my @node=unpackcmd(slurp($_));
		if (! defined $node[1]->{avail}) {
			$node[1]->{avail} = $node[1]->{cpus}-$node[1]->{load};
		}
                push @r, $node[1];
	}
	closedir D;
	return @r;
}

sub startdaemon {
	my ($dkill, $restart, $reload, $node, $all);

	GetOptions("kill"=>\$dkill, "RESTART"=>\$restart, "reload"=>\$reload, "host=s"=>\$node, "all"=>\$all) ||
		die usage();

	$node = '*' if $all;

	if ($reload || $node) {
		my @n = $node ? expandnodes($node) : ([$conf{master},$conf{master_port}]);
	
		my $stat = 0;
		my $xcmd = $reload ? 'relo' : $restart ? 'rest' : $dkill ? 'term' : '';
		if (!$xcmd) { 
			die usage();
		}
		for (@n) { 
			my ($res) = waitmsg($_->[0], $_->[1], "xcmd", $xcmd);
			if (! defined $res) {
				print "$@\n";
				$stat = 1;
			} else {
				print "$res\n";
			}
		}
		exit $stat;
	}

	if ($restart) {
		$daemon = 1;
	}

	killgpid() if $dkill || $restart;
	exit 0 if $dkill;
	sleep 1 if $restart;

	# start daemon
	if ($gpid) {                                             # already running?
		if (kill(0, $gpid)) {
			die "Already running ($gpid), not starting twice\n";
		}
	}
	xlog("note", "Starting daemon as " . getpwuid($<));

	if (!($gpid=fork)) {
		die "Can't fork child process\n" if (! defined $gpid);

		open (P, ">$conf{pid_file}") || die "Can't open pidfile '$conf{pid_file}' : $!\n";
		print P $$;
		close P;                                        # save pid

		open STDIN,  '</dev/null';
		if (! -t STDOUT || ( $conf{log_file} && ! ($conf{log_file} eq '-'))) {
			open STDOUT, '>/dev/null';
			open STDERR, '>&STDOUT';
		}

		chdir '/';

		POSIX::setsid();

		$SIG{INT}  = sub {close $listener; $quit = 1};
		$SIG{TERM} = $SIG{INT};
		$SIG{HUP}  = \&init;

		$listener = IO::Socket::INET->new(Proto=>"tcp",LocalPort=>$conf{port}, LocalAddr=>$conf{bind}, Reuse=>1, Timeout=>1, Listen=>100)
		  or die "Can't make TCP server on port $conf{port}: $@";
		$read_set = new IO::Select();
		$write_set = new IO::Select();
		$read_set->add($listener);
		$quit = 0;
		while (!$quit) {
			eval {readsocks()};
			last if $quit;
			xlog("error", "Daemon readsocks exception: $@") if $@;

			# theoretically these could be in separate threads, or forked off
			if ( $conf{services}->{queue} ) {
				eval {schedule()};
				xlog("error", "Daemon schedule exception: $@") if $@;
			}
			if ( $conf{services}->{exec} ) {
				eval {srvexec()};
				xlog("error", "Daemon srvexec exception: $@") if $@;
			};
		}
		xlog("note", "Shutdown");
		unlink $conf{pid_file};
	}
	exit 0;
}

sub killgpid {
	die "Can't find pid $conf{pid_file} for daemon\n" if !$gpid;
	if (!kill(2, $gpid)) {
		die "Can't kill -INT $gpid: $!\n";
	}
	$gpid = 0;
}

sub samehost {
	my($h1, $h2);
	$h1=host2ip($h1);
	$h2=host2ip($h2);
	# localhost = dig `hostname`
	$h1 =~ s/^(0\.0\.0\.0|127\.0\.0\.1)$/$conf{hostip}/;
	$h2 =~ s/^(0\.0\.0\.0|127\.0\.0\.1)$/$conf{hostip}/;
	return $h1 eq $h2;
}

sub host2ip {
  my (@octets, $raw_addr, $ip);
  return $_[0] if $_[0] =~ /^(\d+\.){3}\d+$/;
  $raw_addr = (gethostbyname($_[0]))[4];
  @octets = unpack("C4", $raw_addr);
  $ip = join(".", @octets);
  return($ip);
}

sub packdump {
	Data::Dumper->new(\@_)->Indent(0)->Terse(1)->Dump();
}

